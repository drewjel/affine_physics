# PeirceProject
This repository supports the collaborative development of Pierce, a system for implementing a *physical semantics* for code. The project name recalls the American logician, Charles Saunders Peirce, who carried out seminal work on logic and semiotics, which is the study of the meanings of symbols.  See https://plato.stanford.edu/entries/peirce-semiotics/. 

## Overview
The problem that this project addresses is that code today is not formally endowed with a physical semantics. It is essentially computational logic without associated *interpretations*. The semantics of ordinary propositional, predicate, and constructive logic, by contrast, are defined in terms of interpretations. An interpretation precisely defines a correspondence between the symbols *within* a set of logical expressions to objects *outside* of the logic, in some *domain of discourse*. Such a domain  lies beyond the syntax and rules of deduction internal to the logic itself.

A programming language is, of course, just a specialized logic; and a computer program is just an expression in such a logic. As a logic, a programming language is equipped with inference rules, often in the style of Hoare logic, that explain precisely how expressions, here programs, are evaluated. 

For decades, the concept of the semantics of a programming language, and of an expression in such a logic, has been linked to the rules for deducing what a program computes. These rules are *internal* to the logic. What is fundamentally missing from this account of the semantics of software is any notion of a formal *interpretation* of a program, in the sense of an explication of the intended meanings of the logical symbols *within* the code, in some domain of discourse *outside of the code*. 

When the code models and controls a cyberphysical system, such as a robot, the domain of discourse is ultimately the physical world, including the system being monitored and controlled. To establish a *formal* (mathematical) interpretation of the code, one takes the domain to be that of mathematical physics: e.g., a world of physical quantities, such as velocities, torques, times, temperatures, and transformations, modeled in the mathematical terms of Euclidean, affine, and vector spaces and other similarly rich and abstract mathematical structures.

This project aims to establish a new formal semantics of code rooted in the definition of *interpretations,* that map logical expressions in code to objects in such domains of discourse. To start, we are focusing on the physical semantics of code for cyber-physicals systems: and for robotics systems, in particular. We hypothesize, and have already produced some substantial evidence for the proposition that, such code is prone to contain many *physical type errors*. These are errors that arise when the type system of the programming language allows operations to occur that are nevertheless inconsistent with the *intended* but not formalized or enforced, *physical interpretations* of such expressions. 

## Physical Type Errors
Software is very frequently over-abstracted from its intended domain of discourse. For example, one might represent a vector in a mathematical vector space, *S*, as nothing but a three-tuple of floating point numbers. Abstracted away is any information about the particular vector space to which the vector belongs, or the particular frame of reference in which its coordinates are expressed. A commonplace example is that simple scalar values in code are used to represent dimensionful physical quantities, such as masses or points in time, with no formal, and therefore no checkable, representation of the assumed physical dimensions or measurement units.  As a result, code that is well typed according to the rules of the programming language can nevertheless perform operations that have no physical meaning in *external* domain of discourse. 

The Mars Polar Orbiter mission was famously lost due to the execution of an internally well typed computation involving quantities expressed in incompatible (English and metric) units. We refer to such errors as *physical type errors*. These are type errors *in the domain of discourse* represented by symbols in the code. Such errors cannot be detected by the type systems of programming languagebecause, by our definition, they involve information that has been abstracted away: that is no longer in the code in a form that can be reasoned about automatically.

## Automated Construction of Interpretations
This project aims not only to establish a new theory of the physical semantics of code but to substantially automate the process of constructing formal interpretations of code to enable physics-level analysis and checking of software-intensive systems. As already noted, code generally does not contain enough computable information to fully determine an interpretation. On the other hand, the over-abstracted representations found in code provides do provide a precise map of where additional information needs to be given to specify a complete interpretation. Our approach thus uses automated syntactic and (programming language-based) semantic analysis of the code to find code elements that require interpretation for a particular purpose, with an *oracle* module, that can take different forms for different applications, providing the additional information needed to establish a complete, formal interpretation of the relevant software code for a given system. 

## A New Approach to Reasoning About Software and the Systems it Runs

It is impossible to reason adequately about system-level behavior from software code stripped of essential domain information. Are there abstract type errors in a given system? No amount of ordinary code analysis can say, because the information necessary to make such a decision is either missing from the code entirely, or is in a form (e.g., comments or variable identifiers) that does not support the levels of completeness, precision, and consistency needed to support rigorous systems engineering analysis. 

For example, a robotics software system might never make explicit certain key about what vector spaces certain vectors belong to that are represented using floating-point arrays in the code. Does a particular scalar represent a point in time or a duration, or a distance, or a point on some line in a geometric space? Information of this kind, that is commonly missing from code, must be provided by other means. Our interpretation builder uses formal domain models, e.g., of vector spaces, along with an *oracle* to obtain the additional information necessary to construct interpretation of such elements in code base. Our system then builds then fully formal, complete interpretations of selected *aspects* of code, such as its representation of physical quantities by mapping such elements to mathematical objects in mathematical structures formalized in the languages of constructive logic proof assistants. 

Such automated proof assistants and the higher-order constructive logics they support, are not only of interest to computer scientists, today, but increasingly to researchers in mathematics, who appreciate the possibilities for formalizing a broad range of structures of interest to the mathematics and physics communities within the exceptionally expressive logics that these tools support. A quick glance at the evolving mathematics library for the Lean Prover gives a quick sense of what is becoming possible in this regard: https://github.com/leanprover-community/mathlib/tree/master/src.  

## New Capablities in Software and Systems Engineering
With a formalized interpretation in hand for a given piece of software, new kinds of reasoning, and new software and systems engineering capabilities, become possible. Our first application is abstract type-checking. We achieve this capability by mapping selected, physically relevant aspects of source code (currently for C++ robotics code) to corresponding expressions in an abstract mathematical language, currently of affine and Euclidean space expressions formalized in the expressive logic of a constructive logic proof assistant. We then rely on the foundational type checking capabilities of these tools to type check expressions *lifted from the code to interpretations in the domain* for abstract type errors.

Prior work has confirmed the difficulty of manually annotating large bodies of code with meta-data for physical units. Our work shows that it is at least possible to take advantage of the sophsticated *type inference* capabilites of such checkers to dramatically reduce the burden of annotating code without writing a single line of additional inferencing software.

There are many directions for future work, building on our concept of software interpretations and on our demonstration prototype system.

## System Function and Architecture

The following diagram provides an overview of the function and architecture of our demonstration prototype system. It maps physical computation code in C++ to corresponding expressions written in terms of a formalization of mathematical vector spaces in the logic of the Lean Prover. These expressions include critical information not present in the code: specifically which of several vector spaces each "vector" in the code belongs to. The space a vector belongs to is part of its *type* in the Lean expressions. The Lean type checker quickly reveals physical type errors in the form of attempts to execution operations in the code that are not meaningful in the physical domain: here adding vectors from different vector spaces. 

![ArchitectureDiagram](https://github.com/kevinsullivan/Peirce/blob/master/doc/images/Architecture.png)

In this diagram, code is orange, the corresponding domain model is green, and purple represents the interpretation, or the mapping, from the former to the latter. The oracle model is a greenish color to indicate that it provides domain information missing from the code. In our current implementation, an oracle just asks the human user for missing physical type information for each expression in the code. Without going into details, suffice it to say that our design is highly modular, extensible, and can readily be adapted to deal with code written in different styles.

## Next Steps

We are about to undertake experimentation involing the use of this approach and technology to check for physical type errors in large bodies of robotics code writtin using ROS, a widely employed framework for control and simulation of robotic systems such sa drones.

## Who's Involved
The project is run by Kevin Sullivan and Sebastian Elbaum. Our graduate student, Hannah Leung, is currently carrying out our initial prototyping work as part of her MS Thesis project. Jian Xiang, not a postdoc at Harvard, worked with Kevin Sullivan helped to develop some of the early ideas around the "lifting" of ordinary code to enriched models formalized in a constructive logic. Sebastian Elbaum and his colleagues have done closely related work on efficienty annotating code with physical units information. The current project aims to vastly generalize from one-dimensional physical units information to arbitrarily complex dimensionful quantities modeled in terms of rich mathematical abstractions, including multi-dimensional Euclidean spaces. Vector-, matrix-, and tensor-valued quantities modeling complex physical phenemena, are well within the scope of the planned work, for example.   

### Clients and Use Cases

By *clients* we mean tools that use interpretations to provide fundamental new software and systems engineering capabilities. First planned among these are checking of code for abstract type errors. Planned work also include generation of test cases to target only states that a system might encounter in the real world; improving program understandability by helping to explain the intended real-world meanings of symbolic expressions in code; and optimization of physical simulations given the enriched constraints that the real-world imposes on the permissible behaviors of the software components of complex systems. 

### Development Infrastructure and Processes
The best way for research team members to work on this project is to download PeirceVM: an Ubuntu VM set up to develop and test the code for this project. It includes Clang, Lean and required Lean libraries, VSCode configured for C++ development, C++ libraries, search path settings, and so on. It will soon include ROS. It's currently about a 30GB VM image file. Kevin Sullivan routinely works on this project on a mid-2015 core i7 MacBook Pro laptop with a 500GB SSD and 16GB of RAM, and on a desktop PC with a core i9-9900k, 64GB or RAM, and a 2TB PCIe NVMe SSD. It's best to work on the desktop machine, but it's viable to work on the laptop. Once you download the exported VM image, import it into VirtualBox (or VMWare Player, though this is not tested). Then run the VM, log into to the *Charles Saunders Peirce* account with a password to be provided, cd into Project/Peirce, do a *git pull* with your own GitHub credentials to get the latest version of the code, launch VS Code from the project directory, do a CTRL-SHIFT-b to compile the code, and then you're then up and running. In a terminal window, do *make install*. This will copy the compiled binary to the bin subdirectory of the top-level project directory. To run the program, go to the top level project directory. You can then run the command, *bin/peirce inputs/<file>.cpp --*. Replace <file> with the name of a C++ file residing in that directory. The program will construct an interpretation, asking you for any required additional information as needed. It will then invoke the Lean Prover automatically to perform *physical* type checking on the given programming code, printing any type error messages in the terminal window. 


## Significance to Systems Engineering

Our first use cases for this work will focus on robotics code, e.g., for UAV drones, programmed in C++ using ROS. One dimension of the the expected significance of this work for the systems engineering community is that it finally gives us a way to lift knowledge from code, to knowledge expressed in terms of the *mathematical physics of the domain*. By lifting code abstractions to physical abstractions formalized in terms of Euclidean spaces and dynamics, for example, we aim to enable physical analysis of code behavior. We think that this work has the potential to provide systemms engineers with significant insights into what the software in their systems is doing, and to make sure that it only performs operations that are consistent with the actual physics of the given systems engineering domain. 

## Who's Involved
The project is run by Kevin Sullivan and Sebastian Elbaum. Our graduate student, Hannah Leung, is carrying out our initial prototyping work as part of her MS Thesis project. Stay tuned.

## Acknowledgements

Kevin Sullivan's work on this project has been supported by the Systems Engineering Research Center. (A proper, SERC-approved acknowledgement will be provided here.) This work draws heavily on prior work by both PIs, including Sullivan's work with Jian Xiang and John Knight, and on Elbaum's work with his colleagues on easing the task of annotating programs with physical (SI) units. 
