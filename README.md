# PeirceProject
This repository supports the collaborative development of Pierce, a system for implementing a *physical semantics* for code. The project name recalls the American logician, Charles Saunders Peirce, who carried out seminal work on logic and semiotics, which is the study of the meanings of symbols.  See https://plato.stanford.edu/entries/peirce-semiotics/. 

## Overview
Software profoundly determines many of the critical properties of the physical systems that it increasingly monitors and controls. Yet today it is hard to impossible to reason sufficiently well about at least some critical system properties based on the software code that drives them. The reason is that software code today lacks what we will call a *physical semantics*. 

Programming code is essentially a computational logic but without what logicians would call associated *interpretations*. By contrast, the semantics of ordinary propositional, predicate, and constructive logic, are defined in terms of interpretations. Interpretations precisely define correspondences between logical symbols, one one hand, and objects *outside* of the logic, in some other *domain of discourse,* often in the physical world, on the other hand. The domains of discourse in terms of which the semantics of traditional logics are defined lie *outside* of the syntax and rules of deduction internal to a given logic. Software today comes without a physical semantics based on formal interpretations to the mathematical physics of real-world applications.

A programming language, and programs written in it, comprise, rather, just the logical half of a logic-interpretation pair on which a semantics can properly be based. A computer program is just an expression in such a logic. It is symbolic. It is, of course, equipped with the laws of deduction that can be applied to explain what a program *computes* in a given enviornment; but such laws to *not* explain what the terms in the code, or in states obtained by evaluating it, are intended to mean in the associated physical domain of discourse. Today's semantics can tell use that 3 + 4 *means* 7, for example; but that fact tells us nothing about *7 of what*?  Moreover, the expression, 3 + 4, type-checks within the logic even if what it represents is the sum of three apples and four oranges. Code that is consistent with respect to its internal logic can be wildly inconsistent when one considers the intended physical interpretations of its terms.

We are lacking an notion of interpretations for programming logic (code) analogous to that of an interpretation for terms in predicate logic. We are thus missing the essential basis for a proper semantics of code. There seems to be a fundamental gap in our conception of software and its meaning here. Remediating it has the potential to fundamentally alter how we develop and reason about software and the physical phenomena with which software-defined computations interact. 

## The Logic of Code
A programming language is a logic. It is equipped with inference rules or other formal definitions, e.g., in the style of Hoare logic, that precisely define the *computational* meanings of code elements: the values to which expressions will evaluate when a program is executed. That is our current understanding of the term *semantics* as applied to programming languages and code. But where are the interpretations analogous to those found in predicate logic? Where are the associations between terms in code, on one hand, and intended *meanings in a worldly domain of discourse*, on the other. Where are the *physical* semantics of code represented today? The answer is that, they're not. This is a huge problem, especially for systems that will interact in complex ways with the physical world: for cyber-physical systems, in general, and for robotic systems, in particular.

## Computational vs. Physical Semantics
For decades, the concept of the semantics of a program has been equated with the direct or indired formal specification of *what the program computes*. In axiomatic semantics, inference rules define what a program computes. They are literal analogs to the inference rules of natural deduction for first-order predicate logic. In denotational semantics, each program elements is mapped to a meaning in some domain, e.g., of partial functions or interactive games, but the purpose again is explain what a piece of code will compute, not what it is meant to represent in a physical world outside of the code and its computational behaviors. The traditional notion of software semantics is thus *internal* to the logic and behavior of the code. What is fundamentally missing from this account of semantics is any notion of an *interpretation* akin to that in predicate logic: a mapping that explicates the intended meanings of expressions in the code in a domain of discourse *outside* that of computational behavior. 

When code maintains a model of, and controls, a physical system, such as an vehicle, the domain of discourse is ultimately of relevant physical phenomena. The quantities represented by symbolic expression in the code (including runtime state) include such things as positions, translations, rotations, velocities, accelerations, forces, torques, masses, temperatures, stress tensors, and so on. What we need are interpretations for code that explain what the objects in the code are intended to mean outside of the code, in the physical domain, or in models of the physical domain expressed not in code but in the languages of mathematical physics: e.g., in the languages of Euclidean, affine, and vector spaces; Minkowski spaces for systems experiencing non-negligible relativistic effects; of symmetry groups and invariants; and of other rich, abstract mathematical structures.

This project aims to establish a new and formal concept of what we will call the *physical semantics of code* rooted in the definition of *interpretations* that map logical expressions in code to objects in physically meaningful domains of discourse, represented in terms of mathematical physics appropriate to the physical domain. To start, we are focusing on establishing a new physical semantics for code for terrestrial robotics systems, such sa drones and drone swarms, in particular. 

## Physical Type Errors
It is of course possible in principle to represent as much of the physical world in code as one chooses to represent. The *engineering* problem is that in practice, software is very frequently always over-abstracted from its domain of discourse. A programmer might represent a vector in an abstract mathematical vector space of *velocities*, as little more than a three-tuple of floating point numbers, perhaps wrapped in a light abstraction: e.g., a "Vector" class providing for vector-vector addition and scalar-vector multiplication operators. The same class might be used to represent a linear functional in the same way: as little more than a three-tuple of floating point numbers. Abstracted away is information about the distinct vector spaces to which these vectors belong, or the frames of reference in which their coordinates are represented. A programming language type would permit these representations to be added, without any *computational* type errors. The result would *looks like* another vector, but it will make no physical sense because the addition of velocities and co-vectors isn't mathematically or physically well defined. When such a value is used as the basis for a system control action caused by outputs to actuators, a catastrophe could ensue.

We hypothesize, and have already produced evidence for the proposition that, code running cyber-physical systems today is prone to this kind of mechanically undetectable *physical type errors*. These are errors that arise when the type system of the programming language allows computational operations to occur that are inconsistent with the *intended physical interpretations* of the code.

A commonplace example is that simple scalar values in code are used to represent dimensionful physical quantities, such as masses or points in time, with no formal, and therefore no checkable, representation of the assumed physical dimensions or measurement units.  As a result, code that is well typed according to the rules of the programming language can nevertheless perform operations that have no physical meaning in *external* domain of discourse. 

The Mars Polar Orbiter mission was famously lost due to the execution of an internally well typed computation involving quantities expressed in incompatible (English and metric) units. We refer to such errors as *physical type errors*. These are type errors *in the domain of discourse* represented by symbols in the code. Such errors cannot be detected by the type systems of programming languagebecause, by our definition, they involve information that has been abstracted away: that is no longer in the code in a form that can be reasoned about automatically.

## Automated Construction of Interpretations
This project aims not only to establish a new theory of the physical semantics of code but to substantially automate the process of constructing formal interpretations of code to enable physics-level analysis and checking of software-intensive systems. As already noted, code generally does not contain enough computable information to fully determine an interpretation. On the other hand, the over-abstracted representations found in code provides do provide a precise map of where additional information needs to be given to specify a complete interpretation. Our approach thus uses automated syntactic and (programming language-based) semantic analysis of the code to find code elements that require interpretation for a particular purpose, with an *oracle* module, that can take different forms for different applications, providing the additional information needed to establish a complete, formal interpretation of the relevant software code for a given system. 

## A New Approach to Reasoning About Software and the Systems it Runs

It is impossible to reason adequately about system-level behavior from software code stripped of essential domain information. Are there abstract type errors in a given system? No amount of ordinary code analysis can say, because the information necessary to make such a decision is either missing from the code entirely, or is in a form (e.g., comments or variable identifiers) that does not support the levels of completeness, precision, and consistency needed to support rigorous systems engineering analysis. 

For example, a robotics software system might never make explicit certain key about what vector spaces certain vectors belong to that are represented using floating-point arrays in the code. Does a particular scalar represent a point in time or a duration, or a distance, or a point on some line in a geometric space? Information of this kind, that is commonly missing from code, must be provided by other means. Our interpretation builder uses formal domain models, e.g., of vector spaces, along with an *oracle* to obtain the additional information necessary to construct interpretation of such elements in code base. Our system then builds then fully formal, complete interpretations of selected *aspects* of code, such as its representation of physical quantities by mapping such elements to mathematical objects in mathematical structures formalized in the languages of constructive logic proof assistants. 

Such automated proof assistants and the higher-order constructive logics they support, are not only of interest to computer scientists, today, but increasingly to researchers in mathematics, who appreciate the possibilities for formalizing a broad range of structures of interest to the mathematics and physics communities within the exceptionally expressive logics that these tools support. A quick glance at the evolving mathematics library for the Lean Prover gives a quick sense of what is becoming possible in this regard: https://github.com/leanprover-community/mathlib/tree/master/src.  

## New Capablities in Software and Systems Engineering
With a formalized interpretation in hand for a given piece of software, new kinds of reasoning, and new software and systems engineering capabilities, become possible. Our first application is abstract type-checking. We achieve this capability by mapping selected, physically relevant aspects of source code (currently for C++ robotics code) to corresponding expressions in an abstract mathematical language, currently of affine and Euclidean space expressions formalized in the expressive logic of a constructive logic proof assistant. We then rely on the foundational type checking capabilities of these tools to type check expressions *lifted from the code to interpretations in the domain* for abstract type errors.

Prior work has confirmed the difficulty of manually annotating large bodies of code with meta-data for physical units. Our work shows that it is at least possible to take advantage of the sophsticated *type inference* capabilites of such checkers to dramatically reduce the burden of annotating code without writing a single line of additional inferencing software.

There are many directions for future work, building on our concept of software interpretations and on our demonstration prototype system.

## System Function and Architecture

The following diagram provides an overview of the function and architecture of our demonstration prototype system. It maps physical computation code in C++ to corresponding expressions written in terms of a formalization of mathematical vector spaces in the logic of the Lean Prover. These expressions include critical information not present in the code: specifically which of several vector spaces each "vector" in the code belongs to. The space a vector belongs to is part of its *type* in the Lean expressions. The Lean type checker quickly reveals physical type errors in the form of attempts to execution operations in the code that are not meaningful in the physical domain: here adding vectors from different vector spaces. 

![ArchitectureDiagram](https://github.com/kevinsullivan/Peirce/blob/master/doc/images/Architecture.png)

In this diagram, code is orange, the corresponding domain of discourse is green. Purple represents the interpretation: the mapping, from the former to the latter, as well as the mechanisms we have developed and demonstrated to construct physical interpretations for code. The oracle model is a greenish color to indicate that it provides crucial domain information missing from the code, such as the physical spaces that different vectors represented in the code are assumed to inhabit. In our current implementation, an oracle asks the human user for missing physical type information for each expression in the code. We are now working on automated mechanisms to provide the bulk of the required information. Without going into details, suffice it to say that our design is highly modular, extensible, and can readily be adapted to deal with code written in project-specific styles.

## Next Steps

We are about to undertake experimentation involing the use of this approach and technology to check for physical type errors in large bodies of robotics code writtin using ROS, a widely employed framework for control and simulation of robotic systems such sa drones.

## Who's Involved
The project is run by Kevin Sullivan and Sebastian Elbaum. Our graduate student, Hannah Leung, is currently carrying out our initial prototyping work as part of her MS Thesis project. Jian Xiang, not a postdoc at Harvard, worked with Kevin Sullivan helped to develop some of the early ideas around the "lifting" of ordinary code to enriched models formalized in a constructive logic. Sebastian Elbaum and his colleagues have done closely related work on efficienty annotating code with physical units information. The current project aims to vastly generalize from one-dimensional physical units information to arbitrarily complex dimensionful quantities modeled in terms of rich mathematical abstractions, including multi-dimensional Euclidean spaces. Vector-, matrix-, and tensor-valued quantities modeling complex physical phenemena, are well within the scope of the planned work, for example.   

### Clients and Use Cases

By *clients* we mean tools that use interpretations to provide fundamental new software and systems engineering capabilities. First planned among these are checking of code for abstract type errors. Planned work also include generation of test cases to target only states that a system might encounter in the real world; improving program understandability by helping to explain the intended real-world meanings of symbolic expressions in code; and optimization of physical simulations given the enriched constraints that the real-world imposes on the permissible behaviors of the software components of complex systems. 

### Development Infrastructure and Processes
The best way for research team members to work on this project is to download PeirceVM: an Ubuntu VM set up to develop and test the code for this project. It includes Clang, Lean and required Lean libraries, VSCode configured for C++ development, C++ libraries, search path settings, and so on. It will soon include ROS. It's currently about a 30GB VM image file. Kevin Sullivan routinely works on this project on a mid-2015 core i7 MacBook Pro laptop with a 500GB SSD and 16GB of RAM, and on a desktop PC with a core i9-9900k, 64GB or RAM, and a 2TB PCIe NVMe SSD. It's best to work on the desktop machine, but it's viable to work on the laptop. Once you download the exported VM image, import it into VirtualBox (or VMWare Player, though this is not tested). Then run the VM, log into to the *Charles Saunders Peirce* account with a password to be provided, cd into Project/Peirce, do a *git pull* with your own GitHub credentials to get the latest version of the code, launch VS Code from the project directory, do a CTRL-SHIFT-b to compile the code, and then you're then up and running. In a terminal window, do *make install*. This will copy the compiled binary to the bin subdirectory of the top-level project directory. To run the program, go to the top level project directory. You can then run the command, *bin/peirce inputs/<file>.cpp --*. Replace <file> with the name of a C++ file residing in that directory. The program will construct an interpretation, asking you for any required additional information as needed. It will then invoke the Lean Prover automatically to perform *physical* type checking on the given programming code, printing any type error messages in the terminal window. 


## Significance to Systems Engineering

Our first use cases for this work will focus on robotics code, e.g., for UAV drones, programmed in C++ using ROS. One dimension of the the expected significance of this work for the systems engineering community is that it finally gives us a way to lift knowledge from code, to knowledge expressed in terms of the *mathematical physics of the domain*. By lifting code abstractions to physical abstractions formalized in terms of Euclidean spaces and dynamics, for example, we aim to enable formal analysis of physical properties of software-driven systems with strong potential to check the consistency of code with given contraints on physical behaviors. We think that this work has the potential to provide new avenues for gaining insight into what software does to physical systems, in part by ensuring that software only performs operations that are consistent with the physical laws of the given system in its environment. 

## Who's Involved
The project is run by Kevin Sullivan and Sebastian Elbaum. Our graduate student, Hannah Leung, is carrying out our initial prototyping work as part of her MS Thesis project. Stay tuned.

## Acknowledgements

Kevin Sullivan's work on this project has been supported by the Systems Engineering Research Center. (A proper, SERC-approved acknowledgement will be provided here.) This work draws heavily on prior work by both PIs, including Sullivan's work with Jian Xiang and John Knight, and on Elbaum's work with his colleagues on easing the task of annotating programs with physical (SI) units. 
