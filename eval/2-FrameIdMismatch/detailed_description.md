**Name:** Frame Id Mismatch
**Issue:** https://github.com/cra-ros-pkg/robot_localization/pull/522/files
**Description:** A user recognized that a function, which essentially operates (calculates covariance from previous measurement, prepares it for future processing) on pose data was not operating correctly when the (wheeled) robot was operating in differential drive mode. Essentially, when in differential drive mode, the function, preparePose, can receive data that originated from the IMU. When this state occurs, the frame id of the pose is set to “target frame”, rather than to the IMU frame, however, the value of the pose is assigned directly from a variable that is patently expressed in terms of the IMU frame. Next, this tainted pose is used to taint subsequent computations, for example, by transforming it from to the target frame TO the target frame, when it should have correctly been transformed from the IMU frame to the target frame.
**Implementation Challenges:**
The complexity of this can vary depending, again, on how we want to model control flow. I discuss three simple approaches to handle this in #3, and I believe that for this issue, the implementation approach should mirror that of #3. I don’t want to duplicate text, although the gist is that we must treat the “poseTmp” variable as either having one interpretation, an “option(al)” interpretation, or having a set of interpretations. All implementation complexity is shared with #3. Then, all we would need to do is demonstrate that a frame type error arises when we assign the location or orientational components of the msg, expressed in terms of the IMU frame, into the poseTmp frame, which is in the “target frame”, which are not necessarily equal. As mentioned elsewhere, these frames are not a part of the dependent types in phys (and arguably should not be), so, as we are not in a coordinate-free paradigm, to enforce this, my preferred approach is to rely on generating an assertion (as described elsewhere). This assertion will be subsequent to the assignment, and will throw an exception/type error, as the frame of the variable does not match the frame of the value being bound. One other distinct implementation concern is poses. Although we have all of the components to describe poses, I have not finished implementing “compound types”. Specifically, a Pose can be thought of as a product type of a Vector and a Quaternion. The simplest way to handle this for now is to treat a Pose as a Pose (i.e., allow the user to annotate it as such, and bind a pose to a pose variable in Lang)..
**Solution Details:**
Again, similar to #3, how we annotate this pose is contingent on how we decide to implement our solution. In either case, we of course instantiate an appropriate world space, etc., but, the rest of the solution varies.