#include "Oracle_LeanInference.h"

# include <string>
# include <iostream>
# include <vector>
#include <memory>

#include <cstdio>
#include <stdexcept>
#include <array>

#include <algorithm> 
#include <functional> 
#include <cctype>
#include <locale>
#include <sstream>

//move to a library file/folder
//pilfered from https://stackoverflow.com/questions/216823/whats-the-best-way-to-trim-stdstring
// trim from start
static inline std::string ltrim(std::string s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(),
            std::not1(std::ptr_fun<int, int>(std::isspace))));
    return s;
}

// trim from end
static inline std::string rtrim(std::string s) {
    s.erase(std::find_if(s.rbegin(), s.rend(),
            std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
    return s;
}

// trim from both ends
static inline std::string trim(std::string s) {
    return ltrim(rtrim(s));
}

//move to a library file/folder
//pilfered from https://stackoverflow.com/questions/478898/how-do-i-execute-a-command-and-get-the-output-of-the-command-within-c-using-po
std::string exec_toString(std::string scmd){//const char* cmd) {
    auto cmd = scmd.c_str();
    std::array<char, 128> buffer;
    std::string result;
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd, "r"), pclose);
    if (!pipe) {
        throw std::runtime_error("popen() failed!");
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }
    return result;
}

//using namespace std;
using namespace oracle;

//yikes, yikes, yikes... copied from Checker.h
struct aFile {
    FILE* file;
    const char* name;
};

void Oracle_LeanInference::generateLeanChecker(std::string peirceOutputName){
    
    aFile* f = new aFile;
    std::string name = peirceOutputName + "_CHECK.lean";//method
    char * name_cstr = new char [name.length()+1];
    strcpy (name_cstr, name.c_str());
    f->name = name_cstr;
    //std::cout<<"Generating file ... " << name_cstr << "\n";
    f->file = fopen(f->name,"w");

    std::string flag_str = "#check \"FLAG\"\n";
    std::string check_str = "#check \"CHECK\"\n";
    std::string eval_str = "#check \"EVAL\"\n";
    std::string math = "import ." + peirceOutputName + "\n" + flag_str;
    for(auto interp_ : this->ordered_nodes){
        math += check_str;
        math += "#check " + interp_->toString() + "\n";
        math += eval_str;
        math += "#eval " + interp_->toString() + "\n";
        math += flag_str;
    }

    fputs(math.c_str(), f->file);
    fclose(f->file);
};

domain::DomainObject* Oracle_LeanInference::getInterpretation(coords::Coords* coords_){
    int selected = 0;
    for(auto i = 0;ordered_nodes.size();i++){
        if(this->ordered_nodes[i]->getCoords() == coords_)
            return this->ordered_interpretations[i];
    }
    return nullptr;
};

/*
This method should be generated by configuration without cases hardcoded

but I don't have time for that today!
*/
int i = 0;
domain::DomainObject* Oracle_LeanInference::parseInterpretation(std::vector<std::string> check_,std::vector<std::string> eval_){
    try{
        std::string checkType = check_[0];
        std::string evalResult = eval_.size() > 0 ? eval_[0] : "sorry";
        //std::cout<<checkType<<"\n";
        std::cout<<i++<<"\n";
        for(auto ln:check_){
            std::cout<<ln<<"\n";
        }

        if(checkType.find("error:") != string::npos || checkType.find("type mismatch") != string::npos){
            auto join_ = std::string("");
            for(auto str_ : check_)
                join_ += str_;
            return new domain::ErrorObject(join_);
        }

    std::string tstr("lang.time.time_expr");
    std::string dstr("lang.time.duration_expr");

    if(evalResult.find("sorry") != string::npos){
        return nullptr;
    }

    if(checkType.find(tstr) != string::npos){
        //return nullptr;
        auto typesub = checkType.substr(checkType.find(tstr));
        auto spaces = domain_->getTimeSpaces();
        auto sp = spaces[0]; //fairly safely assume it's not empty
        auto spname = trim(typesub.substr(std::string(tstr).length()));
        for(auto sp_ : spaces){
            if(sp_->getName() == spname){
                sp = sp_;
                break;
            }
        }
        auto default_value = new float[1];
        default_value[0] = 0;
        return domain_->mkTime("INFERRED", sp,default_value);

    }
    else if(checkType.find(dstr) != string::npos){
        //return nullptr;
        auto typesub = checkType.substr(checkType.find(dstr));
        //std::cout<<"TYPE SUB : "<<typesub<<"\n";
        auto spaces = domain_->getTimeSpaces();
        auto sp = spaces[0]; //fairly safely assume it's not empty
        auto spname = trim(typesub.substr(std::string(dstr).length()));
        //std::cout<<"TYPE SUB : "<<spname<<"\n";
        for(auto sp_ : spaces){
            if(sp_->getName() == spname){
                sp = sp_;
                break;
            }
        }
        auto default_value = new float[1];
        default_value[0] = 0;
        return domain_->mkDuration("INFERRED", sp,default_value);

    }
    //std::cout<<"leaving method";
    return nullptr;
    }
    catch(std::exception ex){
        std::cout<<ex.what()<<"\n";
        return nullptr;
    }
};

void Oracle_LeanInference::buildInterpretations(std::string peirceOutputName){
    this->generateLeanChecker(peirceOutputName);
    std::cout<<"Booting Lean...\n";
    std::string result = exec_toString(std::string("lean /peirce/") + peirceOutputName + "_CHECK.lean");//method
    std::stringstream tosplit(result);

    std::string cur_line;

    while(std::getline(tosplit,cur_line) && cur_line.find("\"FLAG\" : string") == string::npos){
        //std::cout<<"DISCARD LINE : "<<cur_line<<"\n";
    }

    while(
            std::getline(tosplit,cur_line) 
            && cur_line.find("\"CHECK\" : string") != string::npos){
        
        std::vector<std::string> check_, eval_;
        while(
            std::getline(tosplit,cur_line) 
            && cur_line.find("\"EVAL\" : string") == string::npos){
            check_.push_back(cur_line);
        }
        while(
            std::getline(tosplit,cur_line) 
            && cur_line.find("\"FLAG\" : string") == string::npos){
            eval_.push_back(cur_line);
        }
        //std::cout<<"PARSE LINE : "<<check_[0]<<"\n";
        //std::getline(tosplit,eval_line);
        //std::cout<<"EVAL LINE : "<<eval_[0]<<"\n";
        domain::DomainObject* dom_ = this->parseInterpretation(check_, eval_);
        this->ordered_interpretations.push_back(dom_);
        //if(eval_line.find("\"FLAG\" : string") == string::npos){
        //    while(std::getline(tosplit,cur_line) && cur_line.find("\"FLAG\" : string") == string::npos){
        //        std::cout<<"DISCARD LINE : "<<cur_line<<"\n";
        //    }
        //}
    }
};
