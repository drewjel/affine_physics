**Name:** Time Units Mismatch
**Issue:** https://github.com/ros2/geometry2/pull/16
**Description:** A developer in ros::geometry2 noticed that several time-related functions were missing (i.e., not ported from tf yet) while migrating a localization component from the original nav stack. Of particular note, tf::durationFromSec, which allows one to construct a Duration object from an expression object that is expected to uniquely reduce to a value expressed in seconds. While doing this, he noticed that in a few places, people had mistakenly used the direct constructor of tf2::Duration while tf2::durationFromSec was unimplemented, which expects an input expression in nanoseconds rather than seconds, however, they provided literal expressions that whose intended interpretation is in seconds. The author portendingly mentions that others are having issues related to time (“idk if this is the underlying source of any of your TF issues”). Indeed, when perusing the commits related to the pull request, one finds that dozens of “units of measurement” mismatch bugs were uncovered and appropriately fixed by swapping calls from tf2::Duration to tf2::durationFromSec. While many of the bugs manifest in the test suite, many occur in core files. Take an example from from buffer_client.h : BufferClient(std::string ns, double check_frequency = 10.0, tf2::Duration timeout_padding = tf2::Duration(2.0));
This effectively defines a tolerance for timeout on a client, which now has a default value of 2 nanoseconds. As another example from tf2_echo.cpp: 
// Wait for up to one second for the first transforms to become available. 
echoListener.buffer_.canTransform(source_frameid, target_frameid, tf2::TimePoint(), tf2::Duration(1.0));
Now, we see that the function will wait for 1 nanosecond for the transform to become available. Although this may have been earlier in the development of tf2 (2017, the oldest bug on this list), it may be somewhat of a dismay to see dozens of these simple unit errors in core ROS code, and that multiple users were running into and struggling to diagnose these errors.
**Implementation Challenges:** As there are over a dozen different distinct errors demonstrated in over a dozen different files and it is not feasible to implement the entirety of tf2 or ros::geometry2 (at present), we need to select 1 or 2 of these to evince Peirce’s efficacy, while balancing concerns such as clarity and development [time,tradeoffs]. What I believe to be the most effective is from the test suite:
std::vector<tf2::Duration> durations;
durations.push_back(tf2::Duration(0.1));
The challenges include implementing “containers” of some sort in Peirce as well as generating constraints and assertions. I need to be able to parse and annotate generic vectors, and then map them into some sort of generic list structure in Peirce and lang. This list structure will be annotated with a type, for example, “nanosecond vectors” or “velocity vectors”, which is a constraint on values that are used from or emplaced by the vector. Then, since the units of measurement are not part of the dependent type (due to complexities engendered by that approach), my preferred approach is to generate an assertion subsequent to any emplacement or usage that accepts or rejects the unit consistency of the operation. An alternative implementation approach involves being able to annotate the constructor, which would need to be implemented as well. Then, similarly, we would annotate the argument to the constructor as being in nanoseconds, provide a value with an interpretation in seconds, and then, a similar (failing) assertion would be generated. 
**Solution Details:**
We really only need the displayed code snippet to demonstrate the error. We will need to annotate a global time space. Then, we instantiate two measurement systems (SI, and SI with nanoseconds). Then, annotate the (std::)vector as having a “type” of nanosecond vectors in the global time space. When we go to emplace the tf2::Duration, which is expressed in nanoseconds the subsequent unit assertion should fail. Another, and possible simpler way to annotate this, as described above, is to annotate the constructor directly.
