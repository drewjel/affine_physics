**Name:** Transform Orientation Mismatch
**Issue:** https://github.com/cra-ros-pkg/robot_localization/pull/582
**Description:** A user stumbled onto an incorrect transform composition. Three frames are being references (arguably 4): the world frame (odometry), UTM (a geodetic coordinate system), the base link (calculated from IMU data). The questionable portion of code attempts to build a transform from the world frame to UTM (and back, as well). Unfortunately, building this transform is not a trivial operation, as seen below in Latex borrowed from the issue author:

Although we know, a priori, the value of base_link->map, base_link_yaw_only->utm is computed earlier in the method. Essentially, when on a slope, as opposed to a flat surface, one can fathom how base_link and base_link_yaw_only do not reflect the same frames. Thus, the transform is computed incorrectly. The author remedies this by building the transform from base_link_yaw_only->map, and composes that instead with the transform from utm->base_link_yaw_only.
**Implementation Challenges:** There are most likely no implementation challenges. While there is possibly another approach that focuses on elucidating an orientation mismatch between the frames, in my opinion, the equation above demonstrates the error most convincingly. Thus, this is already handled by Peirce, as the annotation primarily relies on demonstrating a transform composition exception, and can be implemented in several hours at most.
**Solution Details:** We would annotate a world space, and several frames as described above (map, utm, base_link, and base_link_yaw_only). Next, we annotate each of the transforms (which are built incrementally, however, we can presumably just annotate the variable here without any loss of information or power). Then, a type error will be directly shown in the transform composition operation, as domain of the outer transform is not the codomain of the inner transform.
