-----------------------------------------------
Using LLVM_SRC_PATH = /llvm
Using LLVM_BUILD_PATH = /llvm/build
Using LLVM_BIN_PATH = /llvm/build/bin
-----------------------------------------------
g++ -O0 -g -Wall `/llvm/build/bin/llvm-config --cxxflags` -I/llvm/tools/clang/include -I/llvm/build/tools/clang/include ASTToCoords.cpp AST.cpp Interpretation.cpp Oracle.cpp Checker.cpp Coords.cpp CoordsToDomain.cpp main.cpp Domain.cpp \
	-Wl,--start-group -lclangAST -lclangASTMatchers -lclangAnalysis -lclangBasic -lclangDriver -lclangEdit -lclangFrontend -lclangFrontendTool -lclangLex -lclangParse -lclangSema -lclangEdit -lclangRewrite -lclangRewriteFrontend -lclangStaticAnalyzerFrontend -lclangStaticAnalyzerCheckers -lclangStaticAnalyzerCore -lclangCrossTU -lclangIndex -lclangSerialization -lclangToolingCore -lclangTooling -lclangFormat -Wl,--end-group `/llvm/build/bin/llvm-config --ldflags --libs --system-libs` -o ../build/ASTMatcher
In file included from Interpretation.h:8:0,
                 from Interpretation.cpp:13:
Oracle.h: In constructor 'oracle::Oracle::Oracle(domain::Domain*)':
Oracle.h:58:18: warning: 'oracle::Oracle::dom_' will be initialized after [-Wreorder]
  domain::Domain* dom_;
                  ^~~~
Oracle.h:57:17: warning:   'domain::Space& oracle::Oracle::space_' [-Wreorder]
  domain::Space& space_;
                 ^~~~~~
Oracle.h:14:2: warning:   when initialized here [-Wreorder]
  Oracle(domain::Domain* d) : dom_(d), space_(*new domain::Space("Oracle:: Error. Stub Space.\n")) {};
  ^~~~~~
Interpretation.cpp: In member function 'void interp::Interpretation::mkVector_Expr(ast::Vector_Expr*, coords::VecExpr*)':
Interpretation.cpp:145:80: error: no matching function for call to 'domain::Vector_Expr::Vector_Expr(coords::Vector_Expr*&, domain::VecExpr*&)'
     domain::Vector_Expr *dom_vec = new domain::Vector_Expr(vec_coords, dom_expr);
                                                                                ^
In file included from Oracle.h:7:0,
                 from Interpretation.h:8,
                 from Interpretation.cpp:13:
Domain.h:237:2: note: candidate: domain::Vector_Expr::Vector_Expr(const domain::Space&, coords::Vector*, domain::VecExpr*)
  Vector_Expr(const Space& s, coords::Vector* c, domain::VecExpr* e) :
  ^~~~~~~~~~~
Domain.h:237:2: note:   candidate expects 3 arguments, 2 provided
Domain.h:235:7: note: candidate: constexpr domain::Vector_Expr::Vector_Expr(const domain::Vector_Expr&)
 class Vector_Expr : public Vector  {
       ^~~~~~~~~~~
Domain.h:235:7: note:   candidate expects 1 argument, 2 provided
Domain.h:235:7: note: candidate: constexpr domain::Vector_Expr::Vector_Expr(domain::Vector_Expr&&)
Domain.h:235:7: note:   candidate expects 1 argument, 2 provided
In file included from Oracle.cpp:4:0:
Oracle.h: In constructor 'oracle::Oracle::Oracle(domain::Domain*)':
Oracle.h:58:18: warning: 'oracle::Oracle::dom_' will be initialized after [-Wreorder]
  domain::Domain* dom_;
                  ^~~~
Oracle.h:57:17: warning:   'domain::Space& oracle::Oracle::space_' [-Wreorder]
  domain::Space& space_;
                 ^~~~~~
Oracle.h:14:2: warning:   when initialized here [-Wreorder]
  Oracle(domain::Domain* d) : dom_(d), space_(*new domain::Space("Oracle:: Error. Stub Space.\n")) {};
  ^~~~~~
Oracle.cpp: At global scope:
Oracle.cpp:23:16: error: redefinition of 'domain::Space& oracle::Oracle::getSpace()'
 domain::Space& Oracle::getSpace() {
                ^~~~~~
In file included from Oracle.cpp:4:0:
Oracle.h:16:17: note: 'domain::Space& oracle::Oracle::getSpace()' previously defined here
  domain::Space& getSpace() { return space_; }
                 ^~~~~~~~
In file included from Coords.cpp:1:0:
Coords.h: In constructor 'coords::Coords::Coords(const clang::Stmt*)':
Coords.h:68:22: warning: 'coords::Coords::clang_stmt_' will be initialized after [-Wreorder]
   const clang::Stmt *clang_stmt_;
                      ^~~~~~~~~~~
Coords.h:67:12: warning:   'coords::ast_type coords::Coords::ast_type_tag_' [-Wreorder]
   ast_type ast_type_tag_;
            ^~~~~~~~~~~~~
Coords.cpp:19:1: warning:   when initialized here [-Wreorder]
 Coords::Coords(const clang::Stmt *stmt) :
 ^~~~~~
In file included from Coords.cpp:1:0:
Coords.h: In constructor 'coords::Coords::Coords(const clang::Decl*)':
Coords.h:69:22: warning: 'coords::Coords::clang_decl_' will be initialized after [-Wreorder]
   const clang::Decl *clang_decl_;
                      ^~~~~~~~~~~
Coords.h:67:12: warning:   'coords::ast_type coords::Coords::ast_type_tag_' [-Wreorder]
   ast_type ast_type_tag_;
            ^~~~~~~~~~~~~
Coords.cpp:23:1: warning:   when initialized here [-Wreorder]
 Coords::Coords(const clang::Decl *decl) :
 ^~~~~~
Coords.cpp: In member function 'virtual std::__cxx11::string coords::VecIdent::toString() const':
Coords.cpp:71:23: error: passing 'const coords::VecIdent' as 'this' argument discards qualifiers [-fpermissive]
     return getVarDecl()->getNameAsString();
                       ^
Coords.cpp:66:23: note:   in call to 'const clang::VarDecl* coords::VecIdent::getVarDecl()'
 const clang::VarDecl *VecIdent::getVarDecl() {
                       ^~~~~~~~
Coords.cpp: At global scope:
Coords.cpp:109:1: error: prototype for 'coords::VecVecAddExpr::VecVecAddExpr(const clang::CXXMemberCallExpr*, coords::Coords*, coords::Coords*)' does not match any in class 'coords::VecVecAddExpr'
 VecVecAddExpr::VecVecAddExpr(
 ^~~~~~~~~~~~~
In file included from Coords.cpp:1:0:
Coords.h:165:7: error: candidates are: constexpr coords::VecVecAddExpr::VecVecAddExpr(coords::VecVecAddExpr&&)
 class VecVecAddExpr : public VecExpr {
       ^~~~~~~~~~~~~
Coords.h:165:7: error:                 constexpr coords::VecVecAddExpr::VecVecAddExpr(const coords::VecVecAddExpr&)
Coords.h:167:3: error:                 coords::VecVecAddExpr::VecVecAddExpr(const clang::CXXMemberCallExpr*, coords::VecExpr*, coords::VecExpr*)
   VecVecAddExpr(const clang::CXXMemberCallExpr *mce, coords::VecExpr *mem, coords::VecExpr *arg);
   ^~~~~~~~~~~~~
Coords.cpp: In member function 'const clang::CXXConstructExpr* coords::Vector::getCXXConstructExpr() const':
Coords.cpp:134:66: error: no matching function for call to 'clang::CXXConstructExpr::CXXConstructExpr(const clang::Stmt* const&)'
     return static_cast<const clang::CXXConstructExpr>(clang_stmt_);
                                                                  ^
In file included from /llvm/tools/clang/include/clang/AST/StmtVisitor.h:16:0,
                 from /llvm/tools/clang/include/clang/AST/AST.h:24,
                 from Coords.h:4,
                 from Coords.cpp:1:
/llvm/tools/clang/include/clang/AST/ExprCXX.h:1312:3: note: candidate: clang::CXXConstructExpr::CXXConstructExpr(clang::Stmt::StmtClass, clang::Stmt::EmptyShell, unsigned int)
   CXXConstructExpr(StmtClass SC, EmptyShell Empty, unsigned NumArgs);
   ^~~~~~~~~~~~~~~~
/llvm/tools/clang/include/clang/AST/ExprCXX.h:1312:3: note:   candidate expects 3 arguments, 1 provided
/llvm/tools/clang/include/clang/AST/ExprCXX.h:1304:3: note: candidate: clang::CXXConstructExpr::CXXConstructExpr(clang::Stmt::StmtClass, clang::QualType, clang::SourceLocation, clang::CXXConstructorDecl*, bool, llvm::ArrayRef<clang::Expr*>, bool, bool, bool, bool, clang::CXXConstructExpr::ConstructionKind, clang::SourceRange)
   CXXConstructExpr(StmtClass SC, QualType Ty, SourceLocation Loc,
   ^~~~~~~~~~~~~~~~
/llvm/tools/clang/include/clang/AST/ExprCXX.h:1304:3: note:   candidate expects 12 arguments, 1 provided
/llvm/tools/clang/include/clang/AST/ExprCXX.h:1261:7: note: candidate: constexpr clang::CXXConstructExpr::CXXConstructExpr(const clang::CXXConstructExpr&)
 class CXXConstructExpr : public Expr {
       ^~~~~~~~~~~~~~~~
/llvm/tools/clang/include/clang/AST/ExprCXX.h:1261:7: note:   no known conversion for argument 1 from 'const clang::Stmt* const' to 'const clang::CXXConstructExpr&'
/llvm/tools/clang/include/clang/AST/ExprCXX.h:1261:7: note: candidate: constexpr clang::CXXConstructExpr::CXXConstructExpr(clang::CXXConstructExpr&&)
/llvm/tools/clang/include/clang/AST/ExprCXX.h:1261:7: note:   no known conversion for argument 1 from 'const clang::Stmt* const' to 'clang::CXXConstructExpr&&'
Coords.cpp: At global scope:
Coords.cpp:153:13: error: prototype for 'std::__cxx11::string coords::Vector_Var::toString()' does not match any in class 'coords::Vector_Var'
 std::string Vector_Var::toString()  {
             ^~~~~~~~~~
In file included from Coords.cpp:1:0:
Coords.h:219:23: error: candidate is: virtual std::__cxx11::string coords::Vector_Var::toString() const
   virtual std::string toString() const;
                       ^~~~~~~~
Coords.cpp:157:13: error: prototype for 'std::__cxx11::string coords::Vector_Expr::toString()' does not match any in class 'coords::Vector_Expr'
 std::string Vector_Expr::toString()  {
             ^~~~~~~~~~~
In file included from Coords.cpp:1:0:
Coords.h:230:23: error: candidate is: virtual std::__cxx11::string coords::Vector_Expr::toString() const
   virtual std::string toString() const;
                       ^~~~~~~~
Coords.cpp: In constructor 'coords::Vector_Expr::Vector_Expr(const clang::CXXConstructExpr*, coords::VecExpr*)':
Coords.cpp:163:45: error: invalid conversion from 'coords::VecExpr*' to 'coords::Vector_Expr*' [-fpermissive]
     : Vector(ast, VEC_CTOR_EXPR), expr_(expr) {
                                             ^
Coords.cpp: In constructor 'coords::Vector_Def::Vector_Def(const clang::DeclStmt*, coords::VecIdent*, coords::VecExpr*)':
Coords.cpp:177:9: error: type 'coords::VecExpr' is not a direct base of 'coords::Vector_Def'
       : VecExpr(declStmt), bv_(bv), be_(be) {
         ^~~~~~~
Coords.cpp:177:17: error: 'declStmt' was not declared in this scope
       : VecExpr(declStmt), bv_(bv), be_(be) {
                 ^~~~~~~~
Coords.cpp:177:17: note: suggested alternative:
In file included from /llvm/tools/clang/include/clang/ASTMatchers/ASTMatchFinder.h:43:0,
                 from Coords.h:5,
                 from Coords.cpp:1:
/llvm/tools/clang/include/clang/ASTMatchers/ASTMatchers.h:1217:68: note:   'clang::ast_matchers::declStmt'
 extern const internal::VariadicDynCastAllOfMatcher<Stmt, DeclStmt> declStmt;
                                                                    ^~~~~~~~
Coords.cpp:177:43: error: no matching function for call to 'coords::Coords::Coords()'
       : VecExpr(declStmt), bv_(bv), be_(be) {
                                           ^
Coords.cpp:23:1: note: candidate: coords::Coords::Coords(const clang::Decl*)
 Coords::Coords(const clang::Decl *decl) :
 ^~~~~~
Coords.cpp:23:1: note:   candidate expects 1 argument, 0 provided
Coords.cpp:19:1: note: candidate: coords::Coords::Coords(const clang::Stmt*)
 Coords::Coords(const clang::Stmt *stmt) :
 ^~~~~~
Coords.cpp:19:1: note:   candidate expects 1 argument, 0 provided
In file included from Coords.cpp:1:0:
Coords.h:50:7: note: candidate: constexpr coords::Coords::Coords(const coords::Coords&)
 class Coords {
       ^~~~~~
Coords.h:50:7: note:   candidate expects 1 argument, 0 provided
Coords.h:50:7: note: candidate: constexpr coords::Coords::Coords(coords::Coords&&)
Coords.h:50:7: note:   candidate expects 1 argument, 0 provided
CoordsToDomain.cpp: In member function 'void coords2domain::CoordsToDomain::putVecIdent(coords::VecIdent*, domain::VecIdent*)':
CoordsToDomain.cpp:11:50: error: no matching function for call to 'std::unordered_map<coords::VecExpr, domain::VecExpr*, coords::VecExprHasher>::insert(std::pair<coords::VecIdent, domain::VecIdent*>)'
     interpExpression.insert(std::make_pair(*c, d));
                                                  ^
In file included from /usr/include/c++/7/unordered_map:48:0,
                 from /llvm/include/llvm/Support/TrigramIndex.h:33,
                 from /llvm/include/llvm/Support/SpecialCaseList.h:57,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerSpecialCaseList.h:19,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerBlacklist.h:17,
                 from /llvm/tools/clang/include/clang/AST/ASTContext.h:41,
                 from /llvm/tools/clang/include/clang/AST/AST.h:17,
                 from Coords.h:4,
                 from CoordsToDomain.h:5,
                 from CoordsToDomain.cpp:1:
/usr/include/c++/7/bits/unordered_map.h:578:7: note: candidate: std::pair<typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::iterator, bool> std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(const value_type&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::iterator = std::__detail::_Node_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type = std::pair<const coords::VecExpr, domain::VecExpr*>]
       insert(const value_type& __x)
       ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:578:7: note:   no known conversion for argument 1 from 'std::pair<coords::VecIdent, domain::VecIdent*>' to 'const value_type& {aka const std::pair<const coords::VecExpr, domain::VecExpr*>&}'
/usr/include/c++/7/bits/unordered_map.h:584:7: note: candidate: std::pair<typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::iterator, bool> std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type&&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::iterator = std::__detail::_Node_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type = std::pair<const coords::VecExpr, domain::VecExpr*>]
       insert(value_type&& __x)
       ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:584:7: note:   no known conversion for argument 1 from 'std::pair<coords::VecIdent, domain::VecIdent*>' to 'std::unordered_map<coords::VecExpr, domain::VecExpr*, coords::VecExprHasher>::value_type&& {aka std::pair<const coords::VecExpr, domain::VecExpr*>&&}'
/usr/include/c++/7/bits/unordered_map.h:591:2: note: candidate: template<class _Pair, class> std::pair<typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::iterator, bool> std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_Pair&&) [with _Pair = _Pair; <template-parameter-2-2> = <template-parameter-1-2>; _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >]
  insert(_Pair&& __x)
  ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:591:2: note:   template argument deduction/substitution failed:
/usr/include/c++/7/bits/unordered_map.h:587:32: error: no type named 'type' in 'struct std::enable_if<false, void>'
       template<typename _Pair, typename = typename
                                ^~~~~~~~
/usr/include/c++/7/bits/unordered_map.h:618:7: note: candidate: std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator, const value_type&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator = std::__detail::_Node_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator = std::__detail::_Node_const_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type = std::pair<const coords::VecExpr, domain::VecExpr*>]
       insert(const_iterator __hint, const value_type& __x)
       ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:618:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/unordered_map.h:624:7: note: candidate: std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator, std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type&&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator = std::__detail::_Node_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator = std::__detail::_Node_const_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type = std::pair<const coords::VecExpr, domain::VecExpr*>]
       insert(const_iterator __hint, value_type&& __x)
       ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:624:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/unordered_map.h:631:2: note: candidate: template<class _Pair, class> std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator, _Pair&&) [with _Pair = _Pair; <template-parameter-2-2> = <template-parameter-1-2>; _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >]
  insert(const_iterator __hint, _Pair&& __x)
  ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:631:2: note:   template argument deduction/substitution failed:
CoordsToDomain.cpp:11:50: note:   candidate expects 2 arguments, 1 provided
     interpExpression.insert(std::make_pair(*c, d));
                                                  ^
In file included from /usr/include/c++/7/unordered_map:48:0,
                 from /llvm/include/llvm/Support/TrigramIndex.h:33,
                 from /llvm/include/llvm/Support/SpecialCaseList.h:57,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerSpecialCaseList.h:19,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerBlacklist.h:17,
                 from /llvm/tools/clang/include/clang/AST/ASTContext.h:41,
                 from /llvm/tools/clang/include/clang/AST/AST.h:17,
                 from Coords.h:4,
                 from CoordsToDomain.h:5,
                 from CoordsToDomain.cpp:1:
/usr/include/c++/7/bits/unordered_map.h:646:2: note: candidate: template<class _InputIterator> void std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator, _InputIterator) [with _InputIterator = _InputIterator; _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >]
  insert(_InputIterator __first, _InputIterator __last)
  ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:646:2: note:   template argument deduction/substitution failed:
CoordsToDomain.cpp:11:50: note:   candidate expects 2 arguments, 1 provided
     interpExpression.insert(std::make_pair(*c, d));
                                                  ^
In file included from /usr/include/c++/7/unordered_map:48:0,
                 from /llvm/include/llvm/Support/TrigramIndex.h:33,
                 from /llvm/include/llvm/Support/SpecialCaseList.h:57,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerSpecialCaseList.h:19,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerBlacklist.h:17,
                 from /llvm/tools/clang/include/clang/AST/ASTContext.h:41,
                 from /llvm/tools/clang/include/clang/AST/AST.h:17,
                 from Coords.h:4,
                 from CoordsToDomain.h:5,
                 from CoordsToDomain.cpp:1:
/usr/include/c++/7/bits/unordered_map.h:657:7: note: candidate: void std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(std::initializer_list<typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::value_type>) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::value_type = std::pair<const coords::VecExpr, domain::VecExpr*>]
       insert(initializer_list<value_type> __l)
       ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:657:7: note:   no known conversion for argument 1 from 'std::pair<coords::VecIdent, domain::VecIdent*>' to 'std::initializer_list<std::pair<const coords::VecExpr, domain::VecExpr*> >'
CoordsToDomain.cpp: In member function 'domain::VecIdent* coords2domain::CoordsToDomain::getVecIdent(coords::VecIdent*) const':
CoordsToDomain.cpp:15:27: error: no match for 'operator[]' (operand types are 'const std::unordered_map<coords::VecExpr, domain::VecExpr*, coords::VecExprHasher>' and 'coords::VecIdent')
    return interpExpression[*c];
                           ^
In file included from /usr/include/c++/7/unordered_map:48:0,
                 from /llvm/include/llvm/Support/TrigramIndex.h:33,
                 from /llvm/include/llvm/Support/SpecialCaseList.h:57,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerSpecialCaseList.h:19,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerBlacklist.h:17,
                 from /llvm/tools/clang/include/clang/AST/ASTContext.h:41,
                 from /llvm/tools/clang/include/clang/AST/AST.h:17,
                 from Coords.h:4,
                 from CoordsToDomain.h:5,
                 from CoordsToDomain.cpp:1:
/usr/include/c++/7/bits/unordered_map.h:975:7: note: candidate: std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type& std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type = domain::VecExpr*; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_type = coords::VecExpr]
       operator[](const key_type& __k)
       ^~~~~~~~
/usr/include/c++/7/bits/unordered_map.h:975:7: note:   no known conversion for argument 1 from 'coords::VecIdent' to 'const key_type& {aka const coords::VecExpr&}'
/usr/include/c++/7/bits/unordered_map.h:979:7: note: candidate: std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type& std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_type&&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type = domain::VecExpr*; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_type = coords::VecExpr]
       operator[](key_type&& __k)
       ^~~~~~~~
/usr/include/c++/7/bits/unordered_map.h:979:7: note:   no known conversion for argument 1 from 'coords::VecIdent' to 'std::unordered_map<coords::VecExpr, domain::VecExpr*, coords::VecExprHasher>::key_type&& {aka coords::VecExpr&&}'
CoordsToDomain.cpp: In member function 'domain::VecVarExpr* coords2domain::CoordsToDomain::getVecVarExpr(coords::VecVarExpr*) const':
CoordsToDomain.cpp:58:64: error: passing 'const std::unordered_map<coords::VecExpr, domain::VecExpr*, coords::VecExprHasher>' as 'this' argument discards qualifiers [-fpermissive]
    return static_cast<domain::VecVarExpr *>(interpExpression[*c]);
                                                                ^
In file included from /usr/include/c++/7/unordered_map:48:0,
                 from /llvm/include/llvm/Support/TrigramIndex.h:33,
                 from /llvm/include/llvm/Support/SpecialCaseList.h:57,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerSpecialCaseList.h:19,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerBlacklist.h:17,
                 from /llvm/tools/clang/include/clang/AST/ASTContext.h:41,
                 from /llvm/tools/clang/include/clang/AST/AST.h:17,
                 from Coords.h:4,
                 from CoordsToDomain.h:5,
                 from CoordsToDomain.cpp:1:
/usr/include/c++/7/bits/unordered_map.h:975:7: note:   in call to 'std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type& std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type = domain::VecExpr*; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_type = coords::VecExpr]'
       operator[](const key_type& __k)
       ^~~~~~~~
CoordsToDomain.cpp: At global scope:
CoordsToDomain.cpp:71:24: error: prototype for 'domain::VecVecAddExpr* coords2domain::CoordsToDomain::getVecVecAddExpr(coords::VecVarExpr*) const' does not match any in class 'coords2domain::CoordsToDomain'
 domain::VecVecAddExpr *CoordsToDomain::getVecVecAddExpr(coords::VecVarExpr* c) const {
                        ^~~~~~~~~~~~~~
In file included from CoordsToDomain.cpp:1:0:
CoordsToDomain.h:52:25: error: candidates are: coords::VecVecAddExpr* coords2domain::CoordsToDomain::getVecVecAddExpr(domain::VecVecAddExpr*) const
  coords::VecVecAddExpr *getVecVecAddExpr(domain::VecVecAddExpr* d) const;
                         ^~~~~~~~~~~~~~~~
CoordsToDomain.h:51:25: error:                 domain::VecVecAddExpr* coords2domain::CoordsToDomain::getVecVecAddExpr(coords::VecVecAddExpr*) const
  domain::VecVecAddExpr *getVecVecAddExpr(coords::VecVecAddExpr* c) const;
                         ^~~~~~~~~~~~~~~~
CoordsToDomain.cpp:75:24: error: prototype for 'coords::VecVecAddExpr* coords2domain::CoordsToDomain::getVecVecAddExpr(domain::VecVarExpr*) const' does not match any in class 'coords2domain::CoordsToDomain'
 coords::VecVecAddExpr *CoordsToDomain::getVecVecAddExpr(domain::VecVarExpr* d) const {
                        ^~~~~~~~~~~~~~
In file included from CoordsToDomain.cpp:1:0:
CoordsToDomain.h:52:25: error: candidates are: coords::VecVecAddExpr* coords2domain::CoordsToDomain::getVecVecAddExpr(domain::VecVecAddExpr*) const
  coords::VecVecAddExpr *getVecVecAddExpr(domain::VecVecAddExpr* d) const;
                         ^~~~~~~~~~~~~~~~
CoordsToDomain.h:51:25: error:                 domain::VecVecAddExpr* coords2domain::CoordsToDomain::getVecVecAddExpr(coords::VecVecAddExpr*) const
  domain::VecVecAddExpr *getVecVecAddExpr(coords::VecVecAddExpr* c) const;
                         ^~~~~~~~~~~~~~~~
CoordsToDomain.cpp: In member function 'void coords2domain::CoordsToDomain::putVector_Lit(coords::Vector*, domain::Vector_Lit*)':
CoordsToDomain.cpp:82:45: error: 'c' was not declared in this scope
     interpExpression.insert(std::make_pair(*c, d));
                                             ^
CoordsToDomain.cpp:82:48: error: 'd' was not declared in this scope
     interpExpression.insert(std::make_pair(*c, d));
                                                ^
CoordsToDomain.cpp: At global scope:
CoordsToDomain.cpp:85:21: error: prototype for 'domain::Vector_Lit* coords2domain::CoordsToDomain::getVector(coords::Vector_Lit*) const' does not match any in class 'coords2domain::CoordsToDomain'
 domain::Vector_Lit *CoordsToDomain::getVector(coords::Vector_Lit* c) const {
                     ^~~~~~~~~~~~~~
In file included from CoordsToDomain.cpp:1:0:
CoordsToDomain.h:62:18: error: candidates are: coords::Vector* coords2domain::CoordsToDomain::getVector(domain::Vector_Expr*) const
  coords::Vector *getVector(domain::Vector_Expr* d) const;
                  ^~~~~~~~~
CoordsToDomain.h:61:18: error:                 domain::Vector* coords2domain::CoordsToDomain::getVector(coords::Vector_Expr*) const
  domain::Vector *getVector(coords::Vector_Expr* c) const;
                  ^~~~~~~~~
CoordsToDomain.h:58:18: error:                 coords::Vector* coords2domain::CoordsToDomain::getVector(domain::Vector_Lit*) const
  coords::Vector *getVector(domain::Vector_Lit* d) const;
                  ^~~~~~~~~
CoordsToDomain.h:57:18: error:                 domain::Vector* coords2domain::CoordsToDomain::getVector(coords::Vector_Lit*) const
  domain::Vector *getVector(coords::Vector_Lit* c) const;
                  ^~~~~~~~~
CoordsToDomain.cpp:89:21: error: prototype for 'coords::Vector_Lit* coords2domain::CoordsToDomain::getVector(domain::Vector_Lit*) const' does not match any in class 'coords2domain::CoordsToDomain'
 coords::Vector_Lit *CoordsToDomain::getVector(domain::Vector_Lit* d) const {
                     ^~~~~~~~~~~~~~
In file included from CoordsToDomain.cpp:1:0:
CoordsToDomain.h:62:18: error: candidates are: coords::Vector* coords2domain::CoordsToDomain::getVector(domain::Vector_Expr*) const
  coords::Vector *getVector(domain::Vector_Expr* d) const;
                  ^~~~~~~~~
CoordsToDomain.h:61:18: error:                 domain::Vector* coords2domain::CoordsToDomain::getVector(coords::Vector_Expr*) const
  domain::Vector *getVector(coords::Vector_Expr* c) const;
                  ^~~~~~~~~
CoordsToDomain.h:58:18: error:                 coords::Vector* coords2domain::CoordsToDomain::getVector(domain::Vector_Lit*) const
  coords::Vector *getVector(domain::Vector_Lit* d) const;
                  ^~~~~~~~~
CoordsToDomain.h:57:18: error:                 domain::Vector* coords2domain::CoordsToDomain::getVector(coords::Vector_Lit*) const
  domain::Vector *getVector(coords::Vector_Lit* c) const;
                  ^~~~~~~~~
CoordsToDomain.cpp: In member function 'void coords2domain::CoordsToDomain::putVector_Expr(coords::Vector*, domain::Vector_Expr*)':
CoordsToDomain.cpp:94:50: error: no matching function for call to 'std::unordered_map<coords::VecExpr, domain::VecExpr*, coords::VecExprHasher>::insert(std::pair<coords::Vector, domain::Vector_Expr*>)'
     interpExpression.insert(std::make_pair(*c, d));
                                                  ^
In file included from /usr/include/c++/7/unordered_map:48:0,
                 from /llvm/include/llvm/Support/TrigramIndex.h:33,
                 from /llvm/include/llvm/Support/SpecialCaseList.h:57,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerSpecialCaseList.h:19,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerBlacklist.h:17,
                 from /llvm/tools/clang/include/clang/AST/ASTContext.h:41,
                 from /llvm/tools/clang/include/clang/AST/AST.h:17,
                 from Coords.h:4,
                 from CoordsToDomain.h:5,
                 from CoordsToDomain.cpp:1:
/usr/include/c++/7/bits/unordered_map.h:578:7: note: candidate: std::pair<typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::iterator, bool> std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(const value_type&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::iterator = std::__detail::_Node_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type = std::pair<const coords::VecExpr, domain::VecExpr*>]
       insert(const value_type& __x)
       ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:578:7: note:   no known conversion for argument 1 from 'std::pair<coords::Vector, domain::Vector_Expr*>' to 'const value_type& {aka const std::pair<const coords::VecExpr, domain::VecExpr*>&}'
/usr/include/c++/7/bits/unordered_map.h:584:7: note: candidate: std::pair<typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::iterator, bool> std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type&&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::iterator = std::__detail::_Node_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type = std::pair<const coords::VecExpr, domain::VecExpr*>]
       insert(value_type&& __x)
       ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:584:7: note:   no known conversion for argument 1 from 'std::pair<coords::Vector, domain::Vector_Expr*>' to 'std::unordered_map<coords::VecExpr, domain::VecExpr*, coords::VecExprHasher>::value_type&& {aka std::pair<const coords::VecExpr, domain::VecExpr*>&&}'
/usr/include/c++/7/bits/unordered_map.h:591:2: note: candidate: template<class _Pair, class> std::pair<typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::iterator, bool> std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_Pair&&) [with _Pair = _Pair; <template-parameter-2-2> = <template-parameter-1-2>; _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >]
  insert(_Pair&& __x)
  ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:591:2: note:   template argument deduction/substitution failed:
/usr/include/c++/7/bits/unordered_map.h:587:32: error: no type named 'type' in 'struct std::enable_if<false, void>'
       template<typename _Pair, typename = typename
                                ^~~~~~~~
/usr/include/c++/7/bits/unordered_map.h:618:7: note: candidate: std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator, const value_type&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator = std::__detail::_Node_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator = std::__detail::_Node_const_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type = std::pair<const coords::VecExpr, domain::VecExpr*>]
       insert(const_iterator __hint, const value_type& __x)
       ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:618:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/unordered_map.h:624:7: note: candidate: std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator, std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type&&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator = std::__detail::_Node_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator = std::__detail::_Node_const_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type = std::pair<const coords::VecExpr, domain::VecExpr*>]
       insert(const_iterator __hint, value_type&& __x)
       ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:624:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/unordered_map.h:631:2: note: candidate: template<class _Pair, class> std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator, _Pair&&) [with _Pair = _Pair; <template-parameter-2-2> = <template-parameter-1-2>; _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >]
  insert(const_iterator __hint, _Pair&& __x)
  ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:631:2: note:   template argument deduction/substitution failed:
CoordsToDomain.cpp:94:50: note:   candidate expects 2 arguments, 1 provided
     interpExpression.insert(std::make_pair(*c, d));
                                                  ^
In file included from /usr/include/c++/7/unordered_map:48:0,
                 from /llvm/include/llvm/Support/TrigramIndex.h:33,
                 from /llvm/include/llvm/Support/SpecialCaseList.h:57,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerSpecialCaseList.h:19,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerBlacklist.h:17,
                 from /llvm/tools/clang/include/clang/AST/ASTContext.h:41,
                 from /llvm/tools/clang/include/clang/AST/AST.h:17,
                 from Coords.h:4,
                 from CoordsToDomain.h:5,
                 from CoordsToDomain.cpp:1:
/usr/include/c++/7/bits/unordered_map.h:646:2: note: candidate: template<class _InputIterator> void std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator, _InputIterator) [with _InputIterator = _InputIterator; _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >]
  insert(_InputIterator __first, _InputIterator __last)
  ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:646:2: note:   template argument deduction/substitution failed:
CoordsToDomain.cpp:94:50: note:   candidate expects 2 arguments, 1 provided
     interpExpression.insert(std::make_pair(*c, d));
                                                  ^
In file included from /usr/include/c++/7/unordered_map:48:0,
                 from /llvm/include/llvm/Support/TrigramIndex.h:33,
                 from /llvm/include/llvm/Support/SpecialCaseList.h:57,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerSpecialCaseList.h:19,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerBlacklist.h:17,
                 from /llvm/tools/clang/include/clang/AST/ASTContext.h:41,
                 from /llvm/tools/clang/include/clang/AST/AST.h:17,
                 from Coords.h:4,
                 from CoordsToDomain.h:5,
                 from CoordsToDomain.cpp:1:
/usr/include/c++/7/bits/unordered_map.h:657:7: note: candidate: void std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(std::initializer_list<typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::value_type>) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::value_type = std::pair<const coords::VecExpr, domain::VecExpr*>]
       insert(initializer_list<value_type> __l)
       ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:657:7: note:   no known conversion for argument 1 from 'std::pair<coords::Vector, domain::Vector_Expr*>' to 'std::initializer_list<std::pair<const coords::VecExpr, domain::VecExpr*> >'
CoordsToDomain.cpp: In member function 'domain::Vector* coords2domain::CoordsToDomain::getVector(coords::Vector_Expr*) const':
CoordsToDomain.cpp:98:62: error: passing 'const std::unordered_map<coords::VecExpr, domain::VecExpr*, coords::VecExprHasher>' as 'this' argument discards qualifiers [-fpermissive]
      return static_cast<domain::Vector *>(interpExpression[*c]);
                                                              ^
In file included from /usr/include/c++/7/unordered_map:48:0,
                 from /llvm/include/llvm/Support/TrigramIndex.h:33,
                 from /llvm/include/llvm/Support/SpecialCaseList.h:57,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerSpecialCaseList.h:19,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerBlacklist.h:17,
                 from /llvm/tools/clang/include/clang/AST/ASTContext.h:41,
                 from /llvm/tools/clang/include/clang/AST/AST.h:17,
                 from Coords.h:4,
                 from CoordsToDomain.h:5,
                 from CoordsToDomain.cpp:1:
/usr/include/c++/7/bits/unordered_map.h:975:7: note:   in call to 'std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type& std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type = domain::VecExpr*; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_type = coords::VecExpr]'
       operator[](const key_type& __k)
       ^~~~~~~~
CoordsToDomain.cpp:98:63: error: invalid static_cast from type 'std::unordered_map<coords::VecExpr, domain::VecExpr*, coords::VecExprHasher>::mapped_type {aka domain::VecExpr*}' to type 'domain::Vector*'
      return static_cast<domain::Vector *>(interpExpression[*c]);
                                                               ^
CoordsToDomain.cpp: At global scope:
CoordsToDomain.cpp:101:71: error: expected ',' or '...' before 'const'
 coords::Vector_Expr *CoordsToDomain::getVector(domain::Vector_Expr* d const) {
                                                                       ^~~~~
CoordsToDomain.cpp:101:22: error: prototype for 'coords::Vector_Expr* coords2domain::CoordsToDomain::getVector(domain::Vector_Expr*)' does not match any in class 'coords2domain::CoordsToDomain'
 coords::Vector_Expr *CoordsToDomain::getVector(domain::Vector_Expr* d const) {
                      ^~~~~~~~~~~~~~
In file included from CoordsToDomain.cpp:1:0:
CoordsToDomain.h:62:18: error: candidates are: coords::Vector* coords2domain::CoordsToDomain::getVector(domain::Vector_Expr*) const
  coords::Vector *getVector(domain::Vector_Expr* d) const;
                  ^~~~~~~~~
CoordsToDomain.cpp:97:17: error:                 domain::Vector* coords2domain::CoordsToDomain::getVector(coords::Vector_Expr*) const
 domain::Vector *CoordsToDomain::getVector(coords::Vector_Expr* c) const {
                 ^~~~~~~~~~~~~~
In file included from CoordsToDomain.cpp:1:0:
CoordsToDomain.h:58:18: error:                 coords::Vector* coords2domain::CoordsToDomain::getVector(domain::Vector_Lit*) const
  coords::Vector *getVector(domain::Vector_Lit* d) const;
                  ^~~~~~~~~
CoordsToDomain.h:57:18: error:                 domain::Vector* coords2domain::CoordsToDomain::getVector(coords::Vector_Lit*) const
  domain::Vector *getVector(coords::Vector_Lit* c) const;
                  ^~~~~~~~~
CoordsToDomain.cpp: In member function 'void coords2domain::CoordsToDomain::putVector_Def(coords::Vector_Def*, domain::Vector_Def*)':
CoordsToDomain.cpp:108:50: error: no matching function for call to 'std::unordered_map<coords::VecExpr, domain::VecExpr*, coords::VecExprHasher>::insert(std::pair<coords::Vector_Def, domain::Vector_Def*>)'
     interpExpression.insert(std::make_pair(*c, d));
                                                  ^
In file included from /usr/include/c++/7/unordered_map:48:0,
                 from /llvm/include/llvm/Support/TrigramIndex.h:33,
                 from /llvm/include/llvm/Support/SpecialCaseList.h:57,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerSpecialCaseList.h:19,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerBlacklist.h:17,
                 from /llvm/tools/clang/include/clang/AST/ASTContext.h:41,
                 from /llvm/tools/clang/include/clang/AST/AST.h:17,
                 from Coords.h:4,
                 from CoordsToDomain.h:5,
                 from CoordsToDomain.cpp:1:
/usr/include/c++/7/bits/unordered_map.h:578:7: note: candidate: std::pair<typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::iterator, bool> std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(const value_type&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::iterator = std::__detail::_Node_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type = std::pair<const coords::VecExpr, domain::VecExpr*>]
       insert(const value_type& __x)
       ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:578:7: note:   no known conversion for argument 1 from 'std::pair<coords::Vector_Def, domain::Vector_Def*>' to 'const value_type& {aka const std::pair<const coords::VecExpr, domain::VecExpr*>&}'
/usr/include/c++/7/bits/unordered_map.h:584:7: note: candidate: std::pair<typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::iterator, bool> std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type&&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::iterator = std::__detail::_Node_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type = std::pair<const coords::VecExpr, domain::VecExpr*>]
       insert(value_type&& __x)
       ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:584:7: note:   no known conversion for argument 1 from 'std::pair<coords::Vector_Def, domain::Vector_Def*>' to 'std::unordered_map<coords::VecExpr, domain::VecExpr*, coords::VecExprHasher>::value_type&& {aka std::pair<const coords::VecExpr, domain::VecExpr*>&&}'
/usr/include/c++/7/bits/unordered_map.h:591:2: note: candidate: template<class _Pair, class> std::pair<typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::iterator, bool> std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_Pair&&) [with _Pair = _Pair; <template-parameter-2-2> = <template-parameter-1-2>; _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >]
  insert(_Pair&& __x)
  ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:591:2: note:   template argument deduction/substitution failed:
/usr/include/c++/7/bits/unordered_map.h:587:32: error: no type named 'type' in 'struct std::enable_if<false, void>'
       template<typename _Pair, typename = typename
                                ^~~~~~~~
/usr/include/c++/7/bits/unordered_map.h:618:7: note: candidate: std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator, const value_type&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator = std::__detail::_Node_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator = std::__detail::_Node_const_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type = std::pair<const coords::VecExpr, domain::VecExpr*>]
       insert(const_iterator __hint, const value_type& __x)
       ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:618:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/unordered_map.h:624:7: note: candidate: std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator, std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type&&) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator = std::__detail::_Node_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator = std::__detail::_Node_const_iterator<std::pair<const coords::VecExpr, domain::VecExpr*>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::value_type = std::pair<const coords::VecExpr, domain::VecExpr*>]
       insert(const_iterator __hint, value_type&& __x)
       ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:624:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/unordered_map.h:631:2: note: candidate: template<class _Pair, class> std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator, _Pair&&) [with _Pair = _Pair; <template-parameter-2-2> = <template-parameter-1-2>; _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >]
  insert(const_iterator __hint, _Pair&& __x)
  ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:631:2: note:   template argument deduction/substitution failed:
CoordsToDomain.cpp:108:50: note:   candidate expects 2 arguments, 1 provided
     interpExpression.insert(std::make_pair(*c, d));
                                                  ^
In file included from /usr/include/c++/7/unordered_map:48:0,
                 from /llvm/include/llvm/Support/TrigramIndex.h:33,
                 from /llvm/include/llvm/Support/SpecialCaseList.h:57,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerSpecialCaseList.h:19,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerBlacklist.h:17,
                 from /llvm/tools/clang/include/clang/AST/ASTContext.h:41,
                 from /llvm/tools/clang/include/clang/AST/AST.h:17,
                 from Coords.h:4,
                 from CoordsToDomain.h:5,
                 from CoordsToDomain.cpp:1:
/usr/include/c++/7/bits/unordered_map.h:646:2: note: candidate: template<class _InputIterator> void std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator, _InputIterator) [with _InputIterator = _InputIterator; _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >]
  insert(_InputIterator __first, _InputIterator __last)
  ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:646:2: note:   template argument deduction/substitution failed:
CoordsToDomain.cpp:108:50: note:   candidate expects 2 arguments, 1 provided
     interpExpression.insert(std::make_pair(*c, d));
                                                  ^
In file included from /usr/include/c++/7/unordered_map:48:0,
                 from /llvm/include/llvm/Support/TrigramIndex.h:33,
                 from /llvm/include/llvm/Support/SpecialCaseList.h:57,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerSpecialCaseList.h:19,
                 from /llvm/tools/clang/include/clang/Basic/SanitizerBlacklist.h:17,
                 from /llvm/tools/clang/include/clang/AST/ASTContext.h:41,
                 from /llvm/tools/clang/include/clang/AST/AST.h:17,
                 from Coords.h:4,
                 from CoordsToDomain.h:5,
                 from CoordsToDomain.cpp:1:
/usr/include/c++/7/bits/unordered_map.h:657:7: note: candidate: void std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(std::initializer_list<typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::value_type>) [with _Key = coords::VecExpr; _Tp = domain::VecExpr*; _Hash = coords::VecExprHasher; _Pred = std::equal_to<coords::VecExpr>; _Alloc = std::allocator<std::pair<const coords::VecExpr, domain::VecExpr*> >; typename std::_Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, std::__detail::_Select1st, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>, std::__detail::__is_noexcept_hash<_Key, _Hash> > >::value, false, true> >::value_type = std::pair<const coords::VecExpr, domain::VecExpr*>]
       insert(initializer_list<value_type> __l)
       ^~~~~~
/usr/include/c++/7/bits/unordered_map.h:657:7: note:   no known conversion for argument 1 from 'std::pair<coords::Vector_Def, domain::Vector_Def*>' to 'std::initializer_list<std::pair<const coords::VecExpr, domain::VecExpr*> >'
CoordsToDomain.cpp: At global scope:
CoordsToDomain.cpp:111:58: error: non-member function 'domain::Vector_Def* getVector_Def(coords::Vector_Def*)' cannot have cv-qualifier
 domain::Vector_Def *getVector_Def(coords::Vector_Def* c) const {
                                                          ^~~~~
CoordsToDomain.cpp: In function 'domain::Vector_Def* getVector_Def(coords::Vector_Def*)':
CoordsToDomain.cpp:112:45: error: 'interpExpression' was not declared in this scope
    return static_cast<domain::Vector_Def *>(interpExpression[*c]);
                                             ^~~~~~~~~~~~~~~~
CoordsToDomain.cpp: At global scope:
CoordsToDomain.cpp:115:58: error: non-member function 'coords::Vector_Def* getVector_Def(domain::Vector_Def*)' cannot have cv-qualifier
 coords::Vector_Def *getVector_Def(domain::Vector_Def* d) const {
                                                          ^~~~~
CoordsToDomain.cpp:120:6: error: prototype for 'void coords2domain::CoordsToDomain::dump() const' does not match any in class 'coords2domain::CoordsToDomain'
 void CoordsToDomain::dump() const {
      ^~~~~~~~~~~~~~
In file included from CoordsToDomain.cpp:1:0:
CoordsToDomain.h:70:7: error: candidate is: void coords2domain::CoordsToDomain::dump()
  void dump();
       ^~~~
In file included from Interpretation.h:8:0,
                 from main.cpp:15:
Oracle.h: In constructor 'oracle::Oracle::Oracle(domain::Domain*)':
Oracle.h:58:18: warning: 'oracle::Oracle::dom_' will be initialized after [-Wreorder]
  domain::Domain* dom_;
                  ^~~~
Oracle.h:57:17: warning:   'domain::Space& oracle::Oracle::space_' [-Wreorder]
  domain::Space& space_;
                 ^~~~~~
Oracle.h:14:2: warning:   when initialized here [-Wreorder]
  Oracle(domain::Domain* d) : dom_(d), space_(*new domain::Space("Oracle:: Error. Stub Space.\n")) {};
  ^~~~~~
main.cpp: In member function 'virtual void HandlerForCXXConstructLitExpr::run(const clang::ast_matchers::MatchFinder::MatchResult&)':
main.cpp:51:17: warning: unused variable 'context' [-Wunused-variable]
     ASTContext *context = Result.Context;
                 ^~~~~~~
main.cpp: In member function 'virtual void HandlerForCXXConstructAddExpr::run(const clang::ast_matchers::MatchFinder::MatchResult&)':
main.cpp:180:90: error: no matching function for call to 'interp::Interpretation::mkVector_Expr(const clang::CXXMemberCallExpr*&, const domain::VecExpr*&)'
     return interp_.mkVector_Expr(vec_vec_add_member_call_ast, memberCallExpr/*, context*/);
                                                                                          ^
In file included from main.cpp:15:0:
Interpretation.h:27:10: note: candidate: void interp::Interpretation::mkVector_Expr(ast::Vector_Expr*, coords::VecExpr*)
     void mkVector_Expr(ast::Vector_Expr *ast, coords::VecExpr* expr/*, clang::ASTContext *context*/);
          ^~~~~~~~~~~~~
Interpretation.h:27:10: note:   no known conversion for argument 1 from 'const clang::CXXMemberCallExpr*' to 'ast::Vector_Expr* {aka const clang::CXXConstructExpr*}'
main.cpp:180:90: error: return-statement with a value, in function returning 'void' [-fpermissive]
     return interp_.mkVector_Expr(vec_vec_add_member_call_ast, memberCallExpr/*, context*/);
                                                                                          ^
main.cpp: In member function 'virtual void VectorDeclStmtHandler::run(const clang::ast_matchers::MatchFinder::MatchResult&)':
main.cpp:451:54: error: void value not ignored as it ought to be
     domain::VecIdent *id = interp_.mkVecIdent(vardecl);
                                                      ^
main.cpp:452:43: error: 'class interp::Interpretation' has no member named 'getCoords'; did you mean 'ast2coords_'?
     coords::VecIdent *id_coords = interp_.getCoords(vardecl);
                                           ^~~~~~~~~
                                           ast2coords_
main.cpp:474:50: error: 'class interp::Interpretation' has no member named 'getCoords'; did you mean 'ast2coords_'?
     const coords::VecExpr *expr_coords = interp_.getCoords(expr);
                                                  ^~~~~~~~~
                                                  ast2coords_
main.cpp:478:12: error: base operand of '->' has non-pointer type 'interp::Interpretation'
     interp_->mkVector_Def(declstmt, id_coords, expr_coords);
            ^~
main.cpp:447:20: warning: unused variable 'sm' [-Wunused-variable]
     SourceManager &sm = context->getSourceManager();
                    ^~
main.cpp:451:23: warning: unused variable 'id' [-Wunused-variable]
     domain::VecIdent *id = interp_.mkVecIdent(vardecl);
                       ^~
main.cpp: In member function 'virtual void MyFrontendAction::EndSourceFileAction()':
main.cpp:532:31: error: 'class interp::Interpretation' has no member named 'isConsistent'
     bool consistent = interp_.isConsistent();
                               ^~~~~~~~~~~~
main.cpp: In function 'int main(int, const char**)':
main.cpp:551:11: error: 'class interp::Interpretation' has no member named 'addSpace'
   interp_.addSpace("S1");
           ^~~~~~~~
main.cpp:552:11: error: 'class interp::Interpretation' has no member named 'addSpace'
   interp_.addSpace("S2");
           ^~~~~~~~
Domain.cpp: In member function 'std::vector<domain::Space>& domain::Domain::getAllSpaces()':
Domain.cpp:38:12: error: invalid initialization of reference of type 'std::vector<domain::Space>&' from expression of type 'std::vector<domain::Space*>'
     return spaces;
            ^~~~~~
Domain.cpp: In member function 'domain::VecVarExpr* domain::Domain::mkVecVarExpr(domain::Space&, coords::VecVarExpr*)':
Domain.cpp:93:12: error: invalid conversion from 'domain::VecExpr*' to 'domain::VecVarExpr*' [-fpermissive]
     return var;
            ^~~
Domain.cpp: At global scope:
Domain.cpp:96:24: error: prototype for 'domain::VecVecAddExpr* domain::Domain::mkVecVecAddExpr(domain::Space&, coords::VecVecAddExpr*, domain::VecExpr*, domain::VecExpr*)' does not match any in class 'domain::Domain'
 domain::VecVecAddExpr *Domain::mkVecVecAddExpr(Space &s, coords::VecVecAddExpr *e, domain::VecExpr *mem, domain::VecExpr *arg)
                        ^~~~~~
In file included from Checker.h:4:0,
                 from Domain.cpp:3:
Domain.h:50:17: error: candidate is: domain::VecVecAddExpr* domain::Domain::mkVecVecAddExpr(domain::Space&, coords::VecVecAddExpr*, coords::VecExpr*, coords::VecExpr*)
  VecVecAddExpr* mkVecVecAddExpr(Space& s, coords::VecVecAddExpr* e, coords::VecExpr* left_, coords::VecExpr* right_);
                 ^~~~~~~~~~~~~~~
Domain.cpp:111:24: error: prototype for 'const domain::VecExpr& domain::VecVecAddExpr::getArgVecExpr()' does not match any in class 'domain::VecVecAddExpr'
 const domain::VecExpr &VecVecAddExpr::getArgVecExpr()
                        ^~~~~~~~~~~~~
In file included from Checker.h:4:0,
                 from Domain.cpp:3:
Domain.h:169:19: error: candidate is: domain::VecExpr* domain::VecVecAddExpr::getArgVecExpr()
  domain::VecExpr *getArgVecExpr();
                   ^~~~~~~~~~~~~
Domain.cpp: In member function 'domain::Vector_Lit* domain::Domain::mkVector_Lit(domain::Space&, coords::Vector*)':
Domain.cpp:123:12: error: invalid conversion from 'domain::Vector*' to 'domain::Vector_Lit*' [-fpermissive]
     return vec;
            ^~~
Domain.cpp: At global scope:
Domain.cpp:126:14: error: prototype for 'domain::Vector_Expr* domain::Domain::mkVector_Expr(domain::Space&, coords::Vector*, domain::VecExpr*)' does not match any in class 'domain::Domain'
 Vector_Expr* Domain::mkVector_Expr(Space& s, coords::Vector* coords, domain::VecExpr* exp) {
              ^~~~~~
In file included from Checker.h:4:0,
                 from Domain.cpp:3:
Domain.h:56:15: error: candidate is: domain::Vector_Expr* domain::Domain::mkVector_Expr(domain::Space&, coords::Vector*, coords::VecExpr*)
  Vector_Expr* mkVector_Expr(Space& space, coords::Vector* v, coords::VecExpr *vec);
               ^~~~~~~~~~~~~
Domain.cpp:148:13: error: prototype for 'domain::Vector_Def* domain::Domain::mkVector_Def(const coords::Vector_Def*, domain::VecIdent*, domain::VecExpr*)' does not match any in class 'domain::Domain'
 Vector_Def *Domain::mkVector_Def(const coords::Vector_Def *v, VecIdent* i,  domain::VecExpr* e)
             ^~~~~~
In file included from Checker.h:4:0,
                 from Domain.cpp:3:
Domain.h:59:14: error: candidate is: domain::Vector_Def* domain::Domain::mkVector_Def(ast::Vector_Def*, coords::VecIdent*, coords::VecExpr*)
  Vector_Def* mkVector_Def(ast::Vector_Def* vardecl, coords::VecIdent* identifier, coords::VecExpr* expression);
              ^~~~~~~~~~~~
Domain.cpp: In member function 'void domain::Domain::dumpVecIdents()':
Domain.cpp:167:24: error: request for member 'toString' in 'i', which is of pointer type 'domain::VecIdent*' (maybe you meant to use '->' ?)
         std::cerr << i.toString() << "\n";
                        ^~~~~~~~
Domain.cpp: In member function 'void domain::Domain::dumpVector_Defs()':
Domain.cpp:181:24: error: request for member 'toString' in 'b', which is of pointer type 'domain::Vector_Def*' (maybe you meant to use '->' ?)
         std::cerr << b.toString() << "\n";
                        ^~~~~~~~
Makefile:110: recipe for target '../build/ASTMatcher' failed
make: *** [../build/ASTMatcher] Error 1
