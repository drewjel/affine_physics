#include <string>
#include <iostream>
#include "clang/AST/AST.h"
#include "clang/AST/ASTConsumer.h"
#include "clang/AST/Expr.h"
#include "clang/ASTMatchers/ASTMatchFinder.h"
#include "clang/ASTMatchers/ASTMatchers.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Frontend/FrontendActions.h"
#include "clang/Rewrite/Core/Rewriter.h"
#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/Tooling.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/CommandLine.h"

#include "CodeCoords.h"
#include "CodeToDomain.h"
#include "Oracle.h"
#include "Domain.h"

using namespace clang;
using namespace clang::ast_matchers;
using namespace clang::driver;
using namespace clang::tooling;
using namespace std;
using namespace llvm;
using namespace domain;

/**************************************************
Fundamental data structure constructed by this tool
***************************************************/

/*
Sharing data via global variables is a bad idea, but we'll 
do it to get a working system. These variables are initialized 
in main() and updated during the parse tree traversal, as AST
node handlers are triggered. 
*/
Oracle *oracle;
Domain *domain_domain;
CodeToDomain *interp;

unordered_map<const clang::Expr *, const ExprASTNode *> expr_wrappers;
unordered_map<const clang::Stmt *, const ExprASTNode *> stmt_wrappers;
unordered_map<const clang::Decl *, const ExprASTNode *> decl_wrappers;

/****************************
Standard Clang Tooling Set-up
*****************************/

/*
Set up a custom category for all command-line options; a help 
message with Clang's standard common command-line options; and 
a tool-specific help message.
*/
static llvm::cl::OptionCategory MyToolCategory("Peirce options");
static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);
static cl::extrahelp MoreHelp("No additional options available for Peirce.");

/*****************************
 * CXXConstructExpr (LITERALS) 
 *****************************/

// Precondition: Given CXXConstructExpr for Vector definition
// Postcondition: identifier, literal value, and binding are in system
//
class HandlerForCXXConstructLitExpr : public MatchFinder::MatchCallback
{
public:
  virtual void run(const MatchFinder::MatchResult &Result)
  {
    cerr << "HandlerForCXXConstructLitExpr. AST:\n";
    ASTContext *context = Result.Context;
    SourceManager &sm = context->getSourceManager();
    const clang::CXXConstructExpr *consdecl /*consdecl*/ = Result.Nodes.getNodeAs<clang::CXXConstructExpr>("VectorLitExpr");

    // Establish postcondition
    //
    // Get space for literal expression
    // Create ast container object for literal AST Node
    // Add tuple from Clang AST to AST wrapper / key
    // Create domain node for lifted AST expression
    // Add (ast container, domain node) to interpretation
    //
    Space &space = oracle->getSpaceForLitVector(consdecl);
    LitASTNode *consdecl_wrapper = new LitASTNode(consdecl);  
    expr_wrappers.insert(std::make_pair(consdecl, consdecl_wrapper));// TODO: Name, consdecl is expr
    expr_wrappers.insert(std::make_pair(consdecl, consdecl_wrapper));
    domain::Expr &br_lit = domain_domain->addVecLitExpr(space, consdecl_wrapper);
    interp->putExpressionInterp(*consdecl_wrapper, br_lit);
    cerr << "END HandlerForCXXConstructLitExpr\n";
  }
};

/*******************************
 * Handle Member Call Expression
 *******************************/

//Forward-reference handlers for member (left) and argument (expressions) of add application
const domain::Expr *handle_member_expr_of_add_call(const clang::Expr *left, ASTContext &context, SourceManager &sm);
const domain::Expr *handle_arg0_of_add_call(const clang::Expr *right, ASTContext &context, SourceManager &sm);



/*
Precondition: 
  - Given CXXMemberCallExpr

Postcondition: 
  - new AST wrapper / key allocated
  - AST to key table (expr_wrappers) updated in this file 
  - VecAddExpr domain object added to domain, linked to domain children
  - Interpretation updated wrapper (code coords) to domain object
  - Return domain object reference

Approach:
*/
const domain::Expr *handleMemberCallExpr(const CXXMemberCallExpr *addexpr, ASTContext *context, SourceManager &sm)
{
  // Get child AST nodes
  //
  const clang::Expr *left = addexpr->getImplicitObjectArgument();
  if (!left) {
    cerr << "handleMemberCallExpr:: Null left clang pointer\n";
    return NULL;
  }
  //left->dump();

  const clang::Expr *right = addexpr->getArg(0);
  if (!right) {
    cerr << "Got null right clang pointer\n";
    return NULL;
  }

  // Handle left and right children
  //
  const domain::Expr *left_br = handle_member_expr_of_add_call(left, *context, sm);
  if (!left_br) {
    cerr << "Got null left domain pointer (STUB)\n";
    return NULL;
  }

  const domain::Expr *right_br = handle_arg0_of_add_call(right, *context, sm);
  if (!right_br) {
    cerr << "Got null right domain pointer (STUB)\n";
    return NULL;
  }
  //
  // Postcondition: left and right children now "in system"


  // Get AST wrapper keys for left and right children
  // Relies on preceding postcondition being satisfied
  const ExprASTNode *left_wrapper = expr_wrappers[left];
  const ExprASTNode *right_wrapper = expr_wrappers[right];
  if (left_wrapper == NULL || right_wrapper == NULL)
  {
    cerr << "BAD WRAPPER\n";
  }

  // Add current member call expression to the system
  //
  cerr << "START: adding member call expression to system\n";
  cerr << "Left child is " << left_br->toString() << " \n";
  cerr << "Right child is " << right_br->toString() << "\n";
  VectorAddExprASTNode *wrapper = new VectorAddExprASTNode(addexpr, left_wrapper, right_wrapper);
  expr_wrappers.insert(std::make_pair(addexpr, wrapper));

  cerr << "Added add expr at " << std::hex << addexpr << " to expr_wrappers\n";
  cerr << "Expression added was \n"; addexpr->dump();

  Space &space = oracle->getSpaceForAddExpression(left_br, right_br);
  const domain::Expr &br_add_expr = domain_domain->addVecAddExpr(space, wrapper, *left_br, *right_br);
  cerr << "New expression now adding is " << br_add_expr.toString() << "\n";
  interp->putExpressionInterp(*wrapper, br_add_expr);
  cerr << "FINISHED: adding member call expression to system\n";
  return &br_add_expr;
}

/*
TODO: CONSIDER inlining this code.
*/
class HandlerForCXXMemberCallExprRight_DeclRefExpr : public MatchFinder::MatchCallback
{
public:
  virtual void run(const MatchFinder::MatchResult &Result)
  {
    const auto *declRefExpr = Result.Nodes.getNodeAs<clang::DeclRefExpr>("DeclRefExpr");
    cerr << "HandlerForCXXMemberCallExprRight_DeclRefExpr: Got declRefExpr = " << std::hex << declRefExpr << "\n";
    // ASTContext *context = Result.Context;
    // SourceManager &sm = context->getSourceManager();
    const VarDeclRefASTNode *wrapper = new VarDeclRefASTNode(declRefExpr);
    expr_wrappers.insert(std::make_pair(declRefExpr, wrapper));
    domain::Expr &be = domain_domain->addVecVarExpr(wrapper);
    interp->putExpressionInterp(*wrapper, be);
    // postcondition, be can now be found through interpret with wrapped declRefExpr as key
  }
};

//CXXMemberCallExpr := CXXMemberCallExprLeft + CXXMemberCallExprRight
class HandlerForCXXAddMemberCall : public MatchFinder::MatchCallback
{
public:
  //  Get left and right children of add expression and handle them by calls to other handlers
  virtual void run(const MatchFinder::MatchResult &Result)
  {
    cerr << "HandlerForCXXAddMemberCall.\n";

    ASTContext *context = Result.Context;
    SourceManager &sm = context->getSourceManager();

    const CXXMemberCallExpr *memcall = Result.Nodes.getNodeAs<clang::CXXMemberCallExpr>("MemberCallExpr");
    if (memcall == NULL)
    {
      cerr << "Error in HandlerForCXXAddMemberCall::run. No memcall pointer\n";
      return;
    }

    const domain::Expr* memberCallExpr = handleMemberCallExpr(memcall, context, sm);

    // TESTING
    const ExprASTNode* addexprWrapper = expr_wrappers[memcall];
    if (!addexprWrapper) {cerr << "Badd Wrapperr\n"; }
    const VectorAddExprASTNode* wrapper = new VectorAddExprASTNode(memcall, NULL, NULL); 
    const domain::Expr *isThere = interp->getExpressionInterp(*wrapper);
    if (!isThere) {cerr << "Missing exprr"; }
/*
    const clang::Expr *left = memcall->getImplicitObjectArgument();
    if (!left)
    {
      cerr << "handleMemberCallExpr:: Null left clang pointer\n";
      return;
    }
    //cerr << "handleMemberCallExpr::run, left is elided\n";
    //left->dump();

    const clang::Expr *right = memcall->getArg(0);
    if (!right)
    {
      cerr << "Got null right clang pointer\n";
      return;
    }
    

    const domain::Expr *left_br = handle_member_expr_of_add_call(left, *context, sm);
    if (!left_br)
    {
      cerr << "Got null left domain pointer (STUB)\n";
      //return;
    }

    const domain::Expr *right_br = handle_arg0_of_add_call(right, *context, sm);
    if (!right_br)
    {
      cerr << "Got null right domain pointer (STUB)\n";
      //return;
    }

    // pre-condition: these objects are already in these maps
    const ExprASTNode *left_wrapper = expr_wrappers[left];
    const ExprASTNode *right_wrapper = expr_wrappers[right];
    if (left_wrapper == NULL || right_wrapper == NULL)
    {
      cerr << "BAD WRAPPER\n";
    }

    cerr << "Joe Blow\n";
    VectorAddExprASTNode *ast = new VectorAddExprASTNode(memcall, left_wrapper, right_wrapper);
    Space &s = oracle->getSpaceForAddExpression(left_br, right_br);
    const domain::Expr &br_add_expr = domain_domain->addVecAddExpr(s, ast, *left_br, *right_br);
    interp->putExpressionInterp(*ast, br_add_expr);
    expr_wrappers.insert(std::make_pair(memcall, ast));
*/
  }
};

/*
Precondition: Provided with match result of type CXXConstructAddExpr
Postcondition: underlying add expression in system, as child of this node, also in system
Strategy:
  - Extract member expression on left, value expression on right
  - Get both of them into the system
  - Add node at this level to the system
*/
class HandlerForCXXConstructAddExpr : public MatchFinder::MatchCallback
{
public:
  //  Get left and right children of add expression and handle them by calls to other handlers
  virtual void run(const MatchFinder::MatchResult &Result)
  {
    cerr << "START HandlerForCXXConstructAddExpr.\n";
    ASTContext *context = Result.Context;
    SourceManager &sm = context->getSourceManager();

    const CXXConstructExpr *consdecl = 
      Result.Nodes.getNodeAs<clang::CXXConstructExpr>("VectorAddExpr");
    if (consdecl == NULL)
    {
      cerr << "Error in HandlerForCXXConstructAddExpr::run. No constructor declaration pointer\n";
      return;
    }

    const CXXMemberCallExpr *addexpr = 
      Result.Nodes.getNodeAs<clang::CXXMemberCallExpr>("MemberCallExpr");
    if (addexpr == NULL)
    {
      cerr << "Error in HandlerForCXXConstructAddExpr::run. No add expression pointer\n";
      cerr << "Surrounding CXXConstructExpr is "; consdecl->dump();
      return;
    }

    const domain::Expr *memberCallExpr = handleMemberCallExpr(addexpr, context, sm);
    const ExprASTNode* addexprWrapper =expr_wrappers[addexpr]; 
    const AddConstructASTNode* wrapper = new AddConstructASTNode(consdecl, addexprWrapper);      
    expr_wrappers.insert(std::make_pair(consdecl,wrapper));
    interp->putExpressionInterp(*wrapper, *memberCallExpr);
    cerr << "END HandlerForCXXConstructAddExpr.\n";
  }
};

/***** Handle Right Expr of expr.add(expr) Call Expr ******/

/*
handle_arg0_of_add_call:

match mem call right expr with
  | decl ref expr ==> decl_ref_expr_handler_
  | cxx member call expr ==> addHandler_
*/
class CXXMemberCallExprArg0Matcher
{
public:
  CXXMemberCallExprArg0Matcher()
  {

    // case: arg0 is a declaration reference expression
    // action: invoke dre_handler_::run as a match finder action
    const StatementMatcher DeclRefExprPattern = declRefExpr().bind("DeclRefExpr");
    CXXMemberCallExprArg0Matcher_.addMatcher(DeclRefExprPattern, &dre_handler_);

    // case: arg0 is a cxx member call expression
    // action: invoke addHandler_::run as a match finder action
    const StatementMatcher CXXMemberCallExprPattern = cxxMemberCallExpr().bind("MemberCallExpr");
    CXXMemberCallExprArg0Matcher_.addMatcher(CXXMemberCallExprPattern, &mce_handler_);
  }

  void match(const clang::Expr &call_rhs, ASTContext &context)
  {
    cerr << "CXXMemberCallExprArg0Matcher::match start\n";
    CXXMemberCallExprArg0Matcher_.match(call_rhs, context);
    cerr << "CXXMemberCallExprArg0Matcher::match finish\n";
  }

private:
  MatchFinder CXXMemberCallExprArg0Matcher_;
  HandlerForCXXMemberCallExprRight_DeclRefExpr dre_handler_;
  HandlerForCXXAddMemberCall mce_handler_;
};

/*
Handle the single argument to an add application 
*/
const domain::Expr *handle_arg0_of_add_call(const clang::Expr *right, ASTContext &context, SourceManager &sm)
{
  cerr << "handle_arg0_of_add_call (match).\n";
  right->dump(); // KJS
  CXXMemberCallExprArg0Matcher call_right_arg0_matcher;
  call_right_arg0_matcher.match(*right, context);

  // postcondition: look up right in interp and return corresponding value
  const ExprASTNode *wrapper = new ExprASTNode(right);
  const domain::Expr *expr = interp->getExpressionInterp(*wrapper);
  expr_wrappers.insert(std::make_pair(right, wrapper));
  //cerr << "END: handle_arg0_of_add_call: returning " << std::hex << expr << ". STUB?\n";
  return expr;
}

/*
handle_member_expr_of_add_call:

match mem call expr with
  | decl ref expr ==> decl_ref_expr_handler_
  | cxx member call expr ==> addHandler_

     // case 1: arg0 is a declaration reference expression
    // action: invoke dre_handler_::run as a match finder action
    // case 2: arg0 is a cxx member call expression
    // action: invoke addHandler_::run as a match finder action
*/
class CXXMemberCallExprMemberExprMatcher
{
public:
  CXXMemberCallExprMemberExprMatcher()
  {
    // member expression is variable
    //
    
    const StatementMatcher DeclRefExprPattern = declRefExpr().bind("DeclRefExpr");
    // KEVIN!!!
    CXXMemberCallExprMemberExprMatcher_.addMatcher(DeclRefExprPattern, &dre_handler_);
    
    //const StatementMatcher DeclRefExprPattern = memberExpr(parenExpr(declRefExpr().bind("LeftDeclRefExpr")));

    // KEVBOB
    const StatementMatcher ParenCXXMemberCallExprPattern = parenExpr(hasDescendant(cxxMemberCallExpr().bind("MemberCallExpr")));

    const StatementMatcher CXXMemberCallExprPattern = cxxMemberCallExpr().bind("MemberCallExpr");

    CXXMemberCallExprMemberExprMatcher_.addMatcher(CXXMemberCallExprPattern, &mce_handler_);
    CXXMemberCallExprMemberExprMatcher_.addMatcher(ParenCXXMemberCallExprPattern, &mce_handler_);
  }

  void match(const clang::Expr &call_rhs, ASTContext &context)
  {
    // NO MATCH HAPPENING HERE!
    cerr << "START CXXMemberCallExprMemberExprMatcher::match start\n";
    call_rhs.dump();
    CXXMemberCallExprMemberExprMatcher_.match(call_rhs, context);
    cerr << "DONE CXXMemberCallExprMemberExprMatcher::match end\n";
  // SOMETHING HERE???
  }

private:
  MatchFinder CXXMemberCallExprMemberExprMatcher_;
  HandlerForCXXMemberCallExprRight_DeclRefExpr dre_handler_;
  HandlerForCXXAddMemberCall mce_handler_;
};

/*
Precondition:
Postcondition: member call expression is "in the system".
Strategy: Pattern matching on structure of member expressions
*/
const domain::Expr *handle_member_expr_of_add_call(const clang::Expr *memexpr, ASTContext &context, SourceManager &sm)
{
  cerr << "START: handle_member_expr_of_add_call by matching: " << std::hex << memexpr << "\n";
  memexpr->dump();
  if (left == NULL)
  {
    cerr << "Error: handle_member_expr_of_add_call - Null argument\n";
  }

  // PROBLEM ZONE
  
  /*
      Match on structure of member expression.
    | vardeclref     :=
    | membercallexpr :=
  */
  cerr << "Foo Matching on memexpr:\n"; memexpr->dump();
  CXXMemberCallExprMemberExprMatcher call_expr_mem_expr_matcher;
  call_expr_mem_expr_matcher.match(*memexpr, context);
  //
  // Postcondition: variable or call expression in system
  // keyed by memexpr (by an AST wrapper around memexpr).
  // Test postcondition.
  cerr << "Now looking it up at " << std::hex << memexpr << "\n";
  const ExprASTNode *wrapper = expr_wrappers[memexpr];//new ExprASTNode(memexpr);
  if (wrapper == NULL) {cerr << "Oops\n";}
  const domain::Expr *expr = interp->getExpressionInterp(*wrapper);
  if (expr == NULL) {cerr << "Didn't find match result\n";}

 
  // establish postcondition
  // nothing to do - should have been done "below" this call

  // expr_wrappers.insert(std::make_pair(left, wrapper));
  // interp->putExpressionInterp(*wrapper,*expr);

  //cerr << "END: handle_member_expr_of_add_call: returning " << std::hex << expr << ". STUB?\n";
  // END PROBLEM ZONE

  return expr;
}


/*
Implements pattern matching and dispatch on CXXConstructExpr

match CXXConstructExpr with
  | literal 3-float initializer ==> lit_handler
  | cxx member call expr (member_expr.add(arg0_expr)==> mem_call_expr_handler
*/
class CXXConstructExprMatcher // (Constructor = Lit | Add left right )
{
public:
  CXXConstructExprMatcher()
  {
    CXXConstructExprMatcher_.addMatcher(cxxConstructExpr(argumentCountIs(3)).bind("VectorLitExpr"), &litHandler_);
    // KEVBOB
    CXXConstructExprMatcher_.addMatcher(cxxConstructExpr(hasDescendant(cxxMemberCallExpr(hasDescendant(memberExpr(hasDeclaration(namedDecl(hasName("vec_add")))))).bind("MemberCallExpr"))).bind("VectorAddExpr"), &addHandler_);
  };
  void match(const clang::CXXConstructExpr *consdecl, ASTContext *context)
  {
    cerr << "START: Pattern Matching on CXXConstructExpr (Lit | Add): Start\n";
    CXXConstructExprMatcher_.match(*consdecl, *context);
    cerr << "DONE: Pattern Matching on CXXConstructExpr (Lit | Add): Start\n";
    //
    // Postcondition: identifier and lit or add expression binding is in system

  }

private:
  MatchFinder CXXConstructExprMatcher_;
  HandlerForCXXConstructLitExpr litHandler_;
  HandlerForCXXConstructAddExpr addHandler_;
};

//--------------------

//const domain::Expr* handleMemberCall

//--------------------

/*
Precondition: consdecl of type CXXConstructExpr* is a pointer to an 
expression, the value of which is being assigned to a variable in a 
declaration statement. 

Explanation: By the time control reaches this code, we are assured 
the argument is an AST node for a Vector-valued expression that is
going to be used to initialize the value of a variable. The purpose 
of this code is to make sure that this C++ expression is "lifted" to
a corresponding expression in the domain, and that the
interpretation links this code/AST-node to that domain object.

Postcondition: the return value of this function is pointer to a new 
object of type domain::Expr; that object is in the domain; it might
itself represent a complex expression tree; it links back to consdecl;
and the interpretation is updated to like consdecl to the new domain
object. This function works recursively to make sure that all of the
work of handling the top-level CXXConstructExpr is finished by the 
time this function returns.

Explanation: the way in which this consdecl is turned into a domain 
object depends on the specific form of the expression being handled.
The cases to be handled include literal and add expressions.
- Vec v1(0.0,0.0,0.0) is a literal expression
- (v1.add(v2)).(v3.add(v4)) is an add expression (recursive)

domain::Expr *handleCXXConstructExpr(const clang::CXXConstructExpr *consdecl, ASTContext *context, SourceManager &sm)
{
  //cerr << "handleCXXConstructExpr: Start handleCXXConstructExpr\n";
  //cerr << "Pattern matching Vector CXXConstructExpr.\n";
  CXXConstructExprMatcher matcher;
  matcher.match(consdecl, context);
  // postcondition: consdecl now has an interpretation
  // How do we get BI to return to user? Look it up
  // domain::Expr* bi = interp->getExpr(consdecl);
  // TO DO: Architectural change means we need to wrap consdecl to map it

  const ExprASTNode *ast = new ExprASTNode(consdecl);   // TODO -- BETTER TYPE!
  domain::Expr *be = interp->getExpressionInterp(*ast);
  //cerr << "handleCXXConstructExpr: Returning Expr at " << std::hex << be << "\n";
  return be;
}
*/

const domain::Expr *handleCXXDeclStmt(const clang::CXXConstructExpr *consdecl, ASTContext *context, SourceManager &sm)
{
  //cerr << "handleCXXConstructExpr: Start handleCXXConstructExpr\n";
  //cerr << "Pattern matching Vector CXXConstructExpr.\n";
  CXXConstructExprMatcher matcher;
  matcher.match(consdecl, context);
  // postcondition: consdecl now has an interpretation
  // How do we get BI to return to user? Look it up
  // domain::Expr* bi = interp->getExpr(consdecl);
  // TO DO: Architectural change means we need to wrap consdecl to map it

  const ExprASTNode *wrapper = new ExprASTNode(consdecl); // TODO -- BETTER TYPE!
  const domain::Expr *be = interp->getExpressionInterp(*wrapper);
  expr_wrappers.insert(std::make_pair(consdecl, wrapper));
  //cerr << "handleCXXConstructExpr: Returning Expr at " << std::hex << be << "\n";
  return be;
}

/*************************
 * Handle Vector DeclStmts
 *************************/

/*
Precondition: Receives a Vector DeclStmt object to handle
Postcondition:
*/

class VectorDeclStmtHandler : public MatchFinder::MatchCallback
{
public:
  virtual void run(const MatchFinder::MatchResult &Result)
  {
    const clang::DeclStmt *declstmt = Result.Nodes.getNodeAs<clang::DeclStmt>("VectorDeclStatement");
    const clang::CXXConstructExpr *consdecl = Result.Nodes.getNodeAs<clang::CXXConstructExpr>("CXXConstructExpr");
    const clang::VarDecl *vardecl = Result.Nodes.getNodeAs<clang::VarDecl>("VarDecl");

    ASTContext *context = Result.Context;
    SourceManager &sm = context->getSourceManager();

    cerr << "VectorDeclStmtHandler:: Decl Statement is \n"; declstmt->dump();
    //cerr << "VectorDeclStmtHandler:: ConstructorExpr is \n"; consdecl->dump();
    //cerr << "VectorDeclStmtHandler:: vardecl is\n"; vardecl->dump();


    // IDENTIFIER -- should call handle identifier (TODO:)
    //
    Space &space = oracle->getSpaceForIdentifier(vardecl);
    IdentifierASTNode *ast_container = new IdentifierASTNode(vardecl);
    decl_wrappers.insert(std::make_pair(vardecl, ast_container));
    domain::Identifier &bi = domain_domain->addIdentifier(space, ast_container);
    interp->putIdentInterp(*ast_container, bi);
    //cerr << "END: handleCXXConstructIdentifier\n";

    // CONSTRUCTOR (Lit | Add)
    //
    cerr << "VectorDeclStmtHandler: matching on consdecl\n";
    CXXConstructExprMatcher matcher;
    matcher.match(consdecl, context);


    // BINDING
    //

    //get result of match, which should be a lit or add expr
    const ExprASTNode *wrapper = new ExprASTNode(consdecl);   
    const domain::Expr *be = interp->getExpressionInterp(*wrapper);
    if (be == NULL)
    {
      cerr << "NULL expression in DeclStmt.\n";
    }
    BindingASTNode *declstmt_wrapper = new BindingASTNode(declstmt);
    stmt_wrappers.insert(std::make_pair(declstmt, declstmt_wrapper));
    domain::Binding &binding = domain_domain->addBinding(declstmt_wrapper, bi, *be);
    interp->putBindingInterp(declstmt_wrapper, binding);


    cerr << "VectorDeclStmtHandler:: Post Domain State \n"; //declstmt->dump();
     cerr << "Domain expressions:\n";
    domain_domain->dumpExpressions(); // print contents on cerr
    cerr << "Domain Identifiers\n";
    domain_domain->dumpIdentifiers(); // print contents on cerr
    cerr << "Domain Bindings\n";
    domain_domain->dumpBindings(); // print contents on cerr
    cerr << "InterpExpressions\n";
    interp->dumpExpressions();
    }
};

/********************************************
 * Top-level analyzer: Match Vector DeclStmts
 ********************************************/

class MyASTConsumer : public ASTConsumer
{
public:
  MyASTConsumer()
  {
    StatementMatcher match_Vector_general_decl =
        declStmt(hasDescendant(varDecl(hasDescendant(cxxConstructExpr(hasType(asString("class Vec"))).bind("CXXConstructExpr"))).bind("VarDecl"))).bind("VectorDeclStatement");
    VectorDeclStmtMatcher.addMatcher(match_Vector_general_decl, &HandlerForVectorDeclStmt);
  }
  void HandleTranslationUnit(ASTContext &Context) override
  {
    VectorDeclStmtMatcher.matchAST(Context);
  }

private:
  MatchFinder VectorDeclStmtMatcher;
  VectorDeclStmtHandler HandlerForVectorDeclStmt;
};

/*******************************
* Main Clang Tooling entry point
********************************/

class MyFrontendAction : public ASTFrontendAction
{
public:
  MyFrontendAction() {}
  void EndSourceFileAction() override
  {
    bool consistent = domain_domain->isConsistent();
    cerr << (consistent ? "STUB Analysis result: Good\n" : "STUB: Bad\n");
  }
  std::unique_ptr<ASTConsumer>
  CreateASTConsumer(CompilerInstance &CI, StringRef file) override
  {
    return llvm::make_unique<MyASTConsumer>();
  }
};

/*****
* Main
******/

int main(int argc, const char **argv)
{
  CommonOptionsParser op(argc, argv, MyToolCategory);
  ClangTool Tool(op.getCompilations(), op.getSourcePathList());
  domain_domain = new Domain();
  domain_domain->addSpace("S1");
  domain_domain->addSpace("S2");
  interp = new CodeToDomain();
  oracle = new Oracle(*domain_domain);
  Tool.run(newFrontendActionFactory<MyFrontendAction>().get());
  cerr << "Identifiers\n";
  domain_domain->dumpIdentifiers();
  cerr << "Expressions\n";
  domain_domain->dumpExpressions();
  cerr << "Bindings\n";
  domain_domain->dumpBindings();
}