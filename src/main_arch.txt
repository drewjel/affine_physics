/*
Domain          Coords              AST             Interp              Clang               Main
------          ------              ---             -------             -----               ----
Space
VecExpr         VecExpr (super)     union           mkVecExpr           
VecLitExpr      VecLitExpr          VecLitExpr      (uses mkVector)
VecIdent        VecIdent            VecIdent        mkVecIdent          CXXConstructExpr    HandlerForCXXConstructLitExpr
VecVarExpr      VecVarExpr          VecVarExpr      mkVecVarExpr        DeclRefExpr         HandlerForCXXMemberCallExprRight_DeclRefExpr
VecVecAddExpr   VecVecAddExpr       VecVecAddExpr   mkVecVecAddExpr     CXXMemberCallExpr   HandlerForCXXAddMemberCall, handleMemberCallExpr
Vector          Vector              Vector          mkVector            CXXConstructExpr    HandlerForCXXConstructAddExpr (recurse member)
Vector_Def      Vector_Def          Vector_Def      mkVector_Def        CXXConstructExpr    VectorDeclStmtHandler, handleCXXDeclStmt (rec)     

                                                                                            CXXMemberCallExprArg0Matcher
                                                                                            handle_arg0_of_add_call (recurse)
                                                                                            CXXMemberCallExprMemberExprMatcher (paren or)
                                                                                            handle_member_expr_of_add_call (Expr*)
                                                                                            CXXConstructExprMatcher (|lit | add)
I was afraid that Vector and VecExpr were going to have the same 
memory address. There's an invariant that has to hold for search
in the maps to work, but I wasn't initially clear about what it had
to be. Now we know. First, (constructed) Vector and (underlying) 
VecExpr are different in the AST. Second, the invariant, as expected, 
is that there are tree-preserving isomorphisms from clang AST nodes
through coords, interp, and then into but not onto the domain. It's
not onto because we add information ot the domain not present in 
the code/AST.
*/

/*
clang::Expr inherits from clang::ValueStmt inherits from clang::Stmt. 

Inheriting from clang::Expr are
  - clang::CXXConstructExpr                 -- constructor call ((member expr + func) + args)
  - clang::DeclRefExpr                      -- reference to variable decl (VarDecl)
  - CXXMemberCallExpr, via CallExpr         --
*/


/*
Domain              Coords
------              ------
Space
VecIdent            VecIdent
Expr                VecExpr
VecLitExpr          VecLitExpr
VecVarExpr          VecVarExpr
VecVecAddExpr       VecVecVecAddExpr
Vector_Def          Vector_Def
Vector              Vector
*/

/*
Interpretation
--------------
mkVecIdent          ast::VecIdent
mkVector_Def        ast::Vector_Def, dom::it, dom::expr
mkVecAddExpr        ast::AddExpr, ast::AddExpr, dom::Expr
mkVecExpr           ast::VecExpr
mkVector            ast::VecLitExpr
mkVector            CXXXConstructExpr
*/





/***********************************************************************************/


Receives            Main                                            Interp              Matches                 Calls
--------
                    MyASTConsumer                                                       VectorDeclStmtHandler
CXXConstructExpr    VectorDeclStmtHandler                           Ident, Def          CXXConstructExprMatcher
CXXConstructExpr    HandlerForCXXConstructLitExpr                   mkVector
DeclRefExpr         HandlerForCXXMemberCallExprRight_DeclRefExpr    mkVecVarExpr 
CXXMemberCallExpr   HandlerForCXXAddMemberCall                      <delegate>                                  handleMemberCallExpr
CXXMemberCallExpr   handleMemberCallExpr                            mkVecVecAddExpr                             handle_member_expr_of_add_call
                                                                                                                handle_arg0_of_add_call
CXXConstructExpr    HandlerForCXXConstructAddExpr                   mkVector                                    handleMemberCallExpr (child)

                    CXXMemberCallExprArg0Matcher                                        DeclRef|Member  
Expr                handle_arg0_of_add_call (recurse)                                   CXXMemberCallExprArg0Matcher
                    CXXMemberCallExprMemberExprMatcher (paren or)                       DeclRef|Member
Expr                handle_member_expr_of_add_call (Expr*)                              CXXMemberCallExprMemberExprMatcher
                    CXXConstructExprMatcher (|lit | add)
CXXConstructExpr    handleCXXDeclStmt                                                   CXXConstructExprMatcher
                                                                                        vector declStmt


MyASTConsumer: {
    foreach d: DeclStmt, match d. using VectorDeclStmtHandler
}

VectorDeclStmtHandler (d : DeclStmt)  {
    id = d.VarDecl
    interp->mkVecIdent(i);
    consdecl = d.CXXConstructExpr
    match ctor using CXXConstructExprMatcher.match(consdecl);
    retrieve expr : domain::VecExpr;
    interp->mkVector_Def(d, id, expr)
}

CXXConstructExprMatcher.match(consdecl)
    match consdecl with 
    | cxxConstructExpr litExpr := HandlerForCXXConstructLitExpr
    | cxxConstructExpr addExpr := HandlerForCXXConstructAddExpr
}

HandlerForCXXConstructLitExpr(CXXConstructExpr litast) {
    interp->mkVector(l, context)
}

HandlerForCXXConstructAddExpr (CXXConstructExpr e) {
    CXXMemberCallExpr vec_vec_add_ctor_ast = e.membercall
    domain::VecExpr mce = handleMemberCallExpr(vec_vec_add_ctor_ast)
    interp->mkVector(vec_vec_add_ctor_ast, mce)
}

handleMemberCallExpr(CXXMemberCallExpr *mce_ast) {
    clang::Expr* mem_ast = mce_ast.implicitArg
    clang::Expr* arg_ast = mce_ast.arg[0]
    dom::VecExpr* left = handle_member_expr_of_add_call(mem_ast)
    dom::VecExpr* right = handle_arg0_of_add_call(arg_ast)
    handle_arg0_of_add_call(arg_ast)
    interp->mkVecVecAddExpr(ast, left_br, right_br);
}

domain::VecExpr *handle_member_expr_of_add_call(clang::Expr *ast) {
    match ast with CXXMemberCallExprMemberExprMatcher.match(ast)
    return interp_->getVecExpr(memexpr)   
}

// problem here, parens
CXXMemberCallExprMemberExprMatcher(Expr* ast) {
    match ast with
    | d: declRefExpr().bind("DeclRefExpr")                                     := HandlerForCXXMemberCallExprRight_DeclRefExpr(d)
    | p: parenExpr(hasDescendant(cxxMemberCallExpr().bind("MemberCallExpr")))  := HandlerForCXXAddMemberCall(p.cxxMemberCallExpr)
    | m: cxxMemberCallExpr().bind("MemberCallExpr")                            := HandlerForCXXAddMemberCall(m)
}

HandlerForCXXMemberCallExprRight_DeclRefExpr(ast: declRefExpr) {
    interp->mkVecVarExpr(declRefExpr)
}

// coupling by side effect
HandlerForCXXAddMemberCall(ast: cxxMemberCallExpr) {
    handleMemberCallExpr(ast); // recurse above
}

domain::VecExpr *handle_arg0_of_add_call(clang::Expr *ast) {
    match ast with CXXMemberCallExprArg0Matcher.match(ast)
    // return value now in interp
    return interp_->getVecExpr(ast)
}

CXXMemberCallExprArg0Matcher(Expr* ast) {
    match as with 
    | declRefExpr().bind("DeclRefExpr") := HandlerForCXXMemberCallExprRight_DeclRefExpr // ?? Variable as argument
    | cxxMemberCallExpr().bind("MemberCallExpr") := HandlerForCXXAddMemberCall
}

END