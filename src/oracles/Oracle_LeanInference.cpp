#include "Oracle_LeanInference.h"

# include <string>
# include <iostream>
# include <vector>
#include <memory>

#include <cstdio>
#include <stdexcept>
#include <array>

#include <algorithm> 
#include <functional> 
#include <cctype>
#include <locale>
#include <sstream>

#include <unistd.h>
#include <chrono>
#include <thread>

#include <unordered_map>

//move to a library file/folder
//pilfered from https://stackoverflow.com/questions/216823/whats-the-best-way-to-trim-stdstring
// trim from start
static inline std::string ltrim(std::string s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(),
            std::not1(std::ptr_fun<int, int>(std::isspace))));
    return s;
}

// trim from end
static inline std::string rtrim(std::string s) {
    s.erase(std::find_if(s.rbegin(), s.rend(),
            std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
    return s;
}

// trim from both ends
static inline std::string trim(std::string s) {
    return ltrim(rtrim(s));
}

//move to a library file/folder
//pilfered from https://stackoverflow.com/questions/478898/how-do-i-execute-a-command-and-get-the-output-of-the-command-within-c-using-po
std::string exec_toString(std::string scmd){//const char* cmd) {
    auto cmd = scmd.c_str();
    std::array<char, 128> buffer;
    std::string result;
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd, "r"), pclose);
    if (!pipe) {
        throw std::runtime_error("popen() failed!");
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }
    return result;
}

//using namespace std;
using namespace oracle;

//yikes, yikes, yikes... copied from Checker.h
struct aFile {
    FILE* file;
    const char* name;
};

//this is a temporary hack generated by the king lear method used to avoid a very obscure bug in the plugin
//also need to work on this a bit more... "ordered_nodes" list need to be rethought 
std::string Oracle_LeanInference::leanInferenceOutputStr(std::string peirceOutputName){
    std::unordered_map<coords::Coords*, int> ident_map;
    //auto ident_ = 0;
    std::string flag_str = "#check \"FLAG\"\n";
    std::string check_str = "#check \"CHECK\"\n";
    std::string eval_str = "#check \"EVAL\"\n";
    std::string math = "import ." + peirceOutputName + "\n" + flag_str;
    for(auto interp_ : this->ordered_nodes){
        math += check_str;
        auto coords_ = interp_->getCoords();
        if(coords_->getNodeType().find("LIST") != string::npos){
            //auto iident_ = ident_map.count(coords_) ? (ident_map[coords_] = ident_map[coords_]++) : (ident_map[coords_] = ident_++);
            math += "#check " + interp_->toString() + "0\n";
            math += eval_str;
            math += "#eval " + interp_->toString() + "0\n";
        }
        else if(coords_->getNodeType().find("APPEND_LIST") != string::npos){
            auto iident_ = (ident_map[coords_->getLinked()] = ident_map[coords_->getLinked()]++);
            math += "#check " + coords_->getLinked()->getName() + std::to_string(iident_)+"\n";
            math += eval_str;
            math += "#eval " + coords_->getLinked()->getName() + std::to_string(iident_)+"\n";
        }
        else{
            math += "#check " + interp_->toString() + "\n";
            math += eval_str;
            math += "#eval " + interp_->toString() + "\n";
        }
        math += flag_str;
    }
    return math;
};

void Oracle_LeanInference::generateLeanChecker(std::string peirceOutputName){
    aFile* f = new aFile;
    std::string name = peirceOutputName + "_CHECK.lean";//method
    char * name_cstr = new char [name.length()+1];
    strcpy (name_cstr, name.c_str());
    f->name = name_cstr;
    f->file = fopen(f->name,"w");

    std::string flag_str = "#check \"FLAG\"\n";
    std::string check_str = "#check \"CHECK\"\n";
    std::string eval_str = "#check \"EVAL\"\n";
    std::string math = "import ." + peirceOutputName + "\n" + flag_str;
    for(auto interp_ : this->ordered_nodes){
        math += check_str;
        if(interp_->getCoords()->getNodeType().find("LIST") != string::npos){
            math += "#check " + interp_->toString() + "0\n";
            math += eval_str;
            math += "#eval " + interp_->toString() + "0\n";
        }
        else{
            math += "#check " + interp_->toString() + "\n";
            math += eval_str;
            math += "#eval " + interp_->toString() + "\n";
        }
        math += flag_str;
    }

    fputs(math.c_str(), f->file);
    fclose(f->file);
    delete f->name;
    delete f;

};

domain::DomainObject* Oracle_LeanInference::getInterpretation(coords::Coords* coords_){
    for(auto i = 0;ordered_nodes.size();i++){
        if(this->ordered_nodes[i]->getCoords() == coords_)
            return this->ordered_interpretations[i];
    }
    return nullptr;
};

/*
This method should be generated by configuration without cases hardcoded

but I don't have time for that today!
*/
int i = 0;
domain::DomainObject* Oracle_LeanInference::parseInterpretation(std::vector<std::string> check_,std::vector<std::string> eval_){
    try{
        std::string checkType = check_.size() > 0 ? check_[0] : "sorry";
        std::string evalResult = eval_.size() > 0 ? eval_[0] : "sorry";

        //std::cout<<checkType<<"\n"<<evalResult<<"\n";

        if(checkType.find("error:") != string::npos 
            || checkType.find("type mismatch") != string::npos
            || checkType.find(": ⁇") != string::npos
            || checkType.find(": list ⁇") != string::npos
            || checkType.find("unknown identifier") != string::npos){
            auto join_ = std::string("");
            for(auto str_ : check_)
                join_ += str_;

            //std::cout<<"join object!!"<<join_<<"\n";
            return new domain::ErrorObject(join_);
        }
        else if(evalResult.find("trying to evaluate sorry") != string::npos 
            || evalResult.find("don't know how to synthesize placeholder") != string::npos){
            auto join_ = std::string("");
            for(auto str_ : evalResult){
                join_ += str_;
            }

            //std::cout<<"join object!!"<<join_<<"\n";
            return new domain::ErrorObject(join_);

        }
        else {
            //std::cout<<"no error detected!\n";
            //std::cout<<checkType<<"\n";
        }

        std::string time_str("lang.time.time_expr");
        std::string duration_str("lang.time.duration_expr");
        std::string time_transform_str("lang.time.time_transform_expr");

        std::string position_str("lang.geom1d.position_expr");
        std::string displacement_str("lang.geom1d.displacement_expr");
        std::string geom1d_transform_str("lang.geom1d.geom1d_transform_expr");

        std::string scalar_str(": scalar");

        if(evalResult.find("sorry") != string::npos){
            return nullptr;
        }

        if(checkType.find(time_str) != string::npos){
            //return nullptr;
            auto typesub = checkType.substr(checkType.find(time_str));
            auto spaces = domain_->getTimeSpaces();
            auto sp = spaces[0]; //fairly safely assume it's not empty
            auto spname = trim(typesub.substr(std::string(time_str).length()));
            for(auto sp_ : spaces){
                if(sp_->getName() == spname){
                    sp = sp_;
                    break;
                }
            }
            auto default_value = new float[1];
            default_value[0] = 0;
            return domain_->mkTime("INFERRED", sp,default_value);

        }
        else if(checkType.find(duration_str) != string::npos){
            auto typesub = checkType.substr(checkType.find(duration_str));
            auto spaces = domain_->getTimeSpaces();
            auto sp = spaces[0]; //fairly safely assume it's not empty
            auto spname = trim(typesub.substr(std::string(duration_str).length()));
            for(auto sp_ : spaces){
                if(sp_->getName() == spname){
                    sp = sp_;
                    break;
                }
            }
            auto default_value = new float[1];
            default_value[0] = 0;
            return domain_->mkDuration("INFERRED", sp,default_value);

        }
        else if(checkType.find(time_transform_str) != string::npos){
            //return nullptr;
            checkType = checkType.substr(checkType.find(time_transform_str));
            auto domcodsub = trim(checkType.substr(std::string(time_transform_str).length()));
            auto domname = trim(domcodsub.substr(0,domcodsub.find(' ')));
            auto codname = trim(domcodsub.substr(domcodsub.find(' ')));

            auto spaces = domain_->getTimeSpaces();
            auto domsp = spaces[0]; //fairly safely assume it's not empty
            auto codsp = spaces[0];
            for(auto sp_ : spaces){
                if(sp_->getName() == domname){
                    domsp = sp_;
                    break;
                }
                if(sp_->getName() == codname){
                    codsp = sp_;
                    break;
                }
            }
            //auto default_value = new float[1];
            //default_value[0] = 0;
            return domain_->mkTimeTransform("INFERRED", domsp, codsp);
            
        }
        else if(checkType.find(position_str) != string::npos){
            //return nullptr;
            auto typesub = checkType.substr(checkType.find(position_str));
            auto spaces = domain_->getGeom1DSpaces();
            auto sp = spaces[0]; //fairly safely assume it's not empty
            auto spname = trim(typesub.substr(std::string(position_str).length()));
            for(auto sp_ : spaces){
                if(sp_->getName() == spname){
                    sp = sp_;
                    break;
                }
            }
            auto default_value = new float[1];
            default_value[0] = 0;
            return domain_->mkPosition("INFERRED", sp,default_value);

        }
        else if(checkType.find(displacement_str) != string::npos){
            //return nullptr;
            auto typesub = checkType.substr(checkType.find(displacement_str));
            auto spaces = domain_->getGeom1DSpaces();
            auto sp = spaces[0]; //fairly safely assume it's not empty
            auto spname = trim(typesub.substr(std::string(displacement_str).length()));
            for(auto sp_ : spaces){
                if(sp_->getName() == spname){
                    sp = sp_;
                    break;
                }
            }
            auto default_value = new float[1];
            default_value[0] = 0;
            return domain_->mkDisplacement("INFERRED", sp,default_value);

        }
        else if(checkType.find(geom1d_transform_str) != string::npos){
            //return nullptr;
            checkType = checkType.substr(checkType.find(geom1d_transform_str));
            auto domcodsub = trim(checkType.substr(std::string(geom1d_transform_str).length()));
            auto domname = trim(domcodsub.substr(0,domcodsub.find(' ')));
            auto codname = trim(domcodsub.substr(domcodsub.find(' ')));

            auto spaces = domain_->getGeom1DSpaces();
            auto domsp = spaces[0]; //fairly safely assume it's not empty
            auto codsp = spaces[0];
            for(auto sp_ : spaces){
                if(sp_->getName() == domname){
                    domsp = sp_;
                    break;
                }
                if(sp_->getName() == codname){
                    codsp = sp_;
                    break;
                }
            }
            //auto default_value = new float[1];
            //default_value[0] = 0;
            return domain_->mkGeom1DTransform("INFERRED", domsp, codsp);
            
        }
        else if(checkType.find(scalar_str) != string::npos){
            //return nullptr;
            auto typesub = checkType.substr(checkType.find(scalar_str));
            auto spaces = domain_->getTimeSpaces();
            auto default_value = new float[1];
            default_value[0] = 0;
            return domain_->mkScalar("INFERRED", default_value);

        }
        return nullptr;
    }
    catch(std::exception ex){
        std::cout<<ex.what()<<"\n";
        return nullptr;
    }
};

std::string bootFile = "/peirce/lean_client/boot.touch";
std::string outputFile = "/peirce/lean_client/output.txt";

std::string bootCmd("touch /peirce/lean_client/boot.touch");
std::string readCmd("cat /peirce/lean_client/output.txt");
std::string cleanCmd("rm /peirce/lean_client/output.txt");

void Oracle_LeanInference::buildInterpretations(std::string peirceOutputName){
    this->ordered_interpretations.clear();
    std::cout<<"Booting Lean...\n";
    //std::string result = exec_toString(std::string("lean /peirce/") + peirceOutputName + "_CHECK.lean");//method
    exec_toString(bootCmd);

    while(access( outputFile.c_str(), F_OK ) == -1)
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
    }

    std::string result = exec_toString(readCmd);
    std::cout<<""<<exec_toString(cleanCmd)<<"";
    
    std::stringstream tosplit(result);

    std::string cur_line;

    int state;
    int 
        preflag=0,
        precheck=1,
        check=2,
        eval=3;

    state = preflag;
    std::vector<std::string> check_, eval_;
    while(std::getline(tosplit,cur_line))
    {
        //std::cout<<cur_line<<"\n";

        switch(state)
        {
            case 0:{
                if(cur_line.find("\"FLAG\" : string") != string::npos){
                    state = precheck;
                }
            } break;
            case 1:{
                if(cur_line.find("\"CHECK\" : string") != string::npos){
                    state = check;
                }
            } break;
            case 2:{
                if(cur_line.find("\"EVAL\" : string") != string::npos){
                    state = eval;
                }
                else {
                    check_.push_back(cur_line);
                }
            } break;
            case 3:{
                if(cur_line.find("\"FLAG\" : string") != string::npos){
                    domain::DomainObject* dom_ = this->parseInterpretation(check_, eval_);
                    this->ordered_interpretations.push_back(dom_);
                    state = precheck;
                    check_.clear();
                    eval_.clear();
                }
                else{
                    eval_.push_back(cur_line);
                }

            } break;
            default: throw "";
        }
    }

    /*
    while(std::getline(tosplit,cur_line) && cur_line.find("\"FLAG\" : string") == string::npos){
        //std::cout<<"DISCARD LINE : "<<cur_line<<"\n";
        std::cout<<"LINE:"<<cur_line<<"\n";
    }

    while(
            std::getline(tosplit,cur_line) 
            && cur_line.find("\"CHECK\" : string") != string::npos){
        std::cout<<"CKLINE:"<<cur_line<<"\n";
        std::vector<std::string> check_, eval_;
        while(
            std::getline(tosplit,cur_line) 
            && cur_line.find("\"EVAL\" : string") == string::npos){
            std::cout<<"EVLINE:"<<cur_line<<"\n";
            check_.push_back(cur_line);
        }
        while(
            std::getline(tosplit,cur_line) 
            && cur_line.find("\"FLAG\" : string") == string::npos){
            std::cout<<"FLLINE:"<<cur_line<<"\n";
            eval_.push_back(cur_line);
        }
        //std::cout<<"PARSE LINE : \n"<<(check_.size()>0? check_[0]:"missing check")<<"\n"<<
        //    (eval_.size()>0?eval_[0]:"missing eval")<<"\n";
        //std::getline(tosplit,eval_line);
        domain::DomainObject* dom_ = this->parseInterpretation(check_, eval_);
        this->ordered_interpretations.push_back(dom_);
        //if(eval_line.find("\"FLAG\" : string") == string::npos){
        //    while(std::getline(tosplit,cur_line) && cur_line.find("\"FLAG\" : string") == string::npos){
        //        std::cout<<"DISCARD LINE : "<<cur_line<<"\n";
        //    }
        //}
    }*/
};
