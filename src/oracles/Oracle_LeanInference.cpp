#include "Oracle_LeanInference.h"

# include <string>
# include <iostream>
# include <vector>
#include <memory>

#include <cstdio>
#include <stdexcept>
#include <array>

#include <algorithm> 
#include <functional> 
#include <cctype>
#include <locale>
#include <sstream>

#include <unistd.h>
#include <chrono>
#include <thread>

#include <stdio.h>

#include <unordered_map>

//move to a library file/folder
//pilfered from https://stackoverflow.com/questions/216823/whats-the-best-way-to-trim-stdstring
// trim from start
static inline std::string ltrim(std::string s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(),
            std::not1(std::ptr_fun<int, int>(std::isspace))));
    return s;
}

// trim from end
static inline std::string rtrim(std::string s) {
    s.erase(std::find_if(s.rbegin(), s.rend(),
            std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
    return s;
}

// trim from both ends
static inline std::string trim(std::string s) {
    return ltrim(rtrim(s));
}

//move to a library file/folder
//pilfered from https://stackoverflow.com/questions/478898/how-do-i-execute-a-command-and-get-the-output-of-the-command-within-c-using-po
std::string exec_toString(std::string scmd){//const char* cmd) {
    auto cmd = scmd.c_str();
    std::array<char, 128> buffer;
    std::string result;
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd, "r"), pclose);
    if (!pipe) {
        throw std::runtime_error("popen() failed!");
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }
    return result;
}

std::vector<int> charPos(std::string str, char delim){
    std::vector<int> positions;

    for(std::string::size_type i = 0;i<str.length();i++){
        if(str[i] == delim)
            positions.push_back(i);
    }
    return positions;
}

//using namespace std;
using namespace oracle;

//yikes, yikes, yikes... copied from Checker.h
struct aFile {
    FILE* file;
    const char* name;
};

//this is a temporary hack generated by the king lear method used to avoid a very obscure bug in the plugin
//also need to work on this a bit more... "ordered_nodes" list need to be rethought 
std::string Oracle_LeanInference::leanInferenceOutputStr(std::string peirceOutputName){
    std::unordered_map<coords::Coords*, int> ident_map;
    //auto ident_ = 0;
    std::string flag_str = "#check \"FLAG\"\n";
    std::string check_str = "#check \"CHECK\"\n";
    std::string eval_str = "#check \"EVAL\"\n";
    std::string math = "import ." + peirceOutputName + "\nopen peirce_output\n" + flag_str;
    for(auto interp_ : this->ordered_nodes){
        math += check_str;
        auto coords_ = interp_->getCoords();
        if(coords_->getNodeType().find("LIST") != string::npos){
            //auto iident_ = ident_map.count(coords_) ? (ident_map[coords_] = ident_map[coords_]++) : (ident_map[coords_] = ident_++);
            math += "#check " + interp_->toString() + "0\n";
            math += eval_str;
            math += "#eval " + interp_->toString() + "0\n";
        }
        else if(coords_->getNodeType().find("APPEND_LIST") != string::npos){
            auto iident_ = (ident_map[coords_->getLinked()] = ident_map[coords_->getLinked()]++);
            math += "#check " + coords_->getLinked()->getName() + std::to_string(iident_)+"\n";
            math += eval_str;
            math += "#eval " + coords_->getLinked()->getName() + std::to_string(iident_)+"\n";
        }
        else{
            math += "#check " + interp_->toString() + "\n";
            math += eval_str;
            math += "#eval " + interp_->toString() + "\n";
        }
        math += flag_str;
    }
    return math;
};

void Oracle_LeanInference::generateLeanChecker(std::string peirceOutputName){
    aFile* f = new aFile;
    std::string name = peirceOutputName + "_CHECK.lean";//method
    char * name_cstr = new char [name.length()+1];
    strcpy (name_cstr, name.c_str());
    f->name = name_cstr;
    f->file = fopen(f->name,"w");

    std::string flag_str = "#check \"FLAG\"\n";
    std::string check_str = "#check \"CHECK\"\n";
    std::string eval_str = "#check \"EVAL\"\n";
    std::string math = "import ." + peirceOutputName + "\n" + flag_str;
    for(auto interp_ : this->ordered_nodes){
        math += check_str;
        if(interp_->getCoords()->getNodeType().find("LIST") != string::npos){
            math += "#check " + interp_->toString() + "0\n";
            math += eval_str;
            math += "#eval " + interp_->toString() + "0\n";
        }
        else{
            math += "#check " + interp_->toString() + "\n";
            math += eval_str;
            math += "#eval " + interp_->toString() + "\n";
        }
        math += flag_str;
    }

    fputs(math.c_str(), f->file);
    fclose(f->file);
    delete f->name;
    delete f;

};

domain::DomainObject* Oracle_LeanInference::getInterpretation(coords::Coords* coords_){
    for(auto i = 0;ordered_nodes.size();i++){
        if(this->ordered_nodes[i]->getCoords() == coords_)
            return this->ordered_interpretations[i];
    }
    return nullptr;
};

domain::DomainObject* Oracle_LeanInference::getAllInterpretation(coords::Coords* coords_){
    for(auto i = 0;all_nodes.size();i++){
        if(this->all_nodes[i]->getCoords() == coords_)
            return this->all_interpretations[i];
    }
    return nullptr;
};

/*
This method should be generated by configuration without cases hardcoded

but I don't have time for that today!
*/
int i = 0;
domain::DomainObject* Oracle_LeanInference::parseInterpretation(std::string type_, std::string error_){
    try{
        //std::cout<<"matching\n";
        //std::cout<<type_<<"\n"<<error_<<"\n";

        if(type_=="None" and error_ == "None")
            return nullptr;
        if(error_ != "None" and (type_.find("⊢ ") == string::npos))
            return new domain::ErrorObject(error_);

        std::string time_str("time_expr");
        std::string duration_str("duration_expr");
        std::string time_transform_str("time_transform_expr");

        std::string position1d_str("position1d_expr");
        std::string displacement1d_str("displacement1d_expr");
        std::string geom1d_transform_str("geom1d_transform_expr");

        std::string timestamped_pose3d_str("timestamped_pose3d_expr");
        std::string timestamped_geom3d_transform_str("timestamped_geom3d_transform_expr");

        std::string position3d_str("position3d_expr");
        std::string displacement3d_str("displacement3d_expr");
        std::string geom3d_transform_str("geom3d_transform_expr");

        std::string orientation3d_str("orientation3d_expr");
        std::string rotation3d_str("rotation3d_expr");
        std::string pose3d_str("pose3d_expr");

        std::string scalar_str("scalar_expr");
        type_.erase(std::remove(type_.begin(), type_.end(), '\''), type_.end());
        type_ = type_.substr(type_.find("⊢") + std::string("⊢ ").length());
        if(type_.find("list ") != string::npos){
            type_ = type_.substr(std::string("list ").length());
        }
        //std::cout<<"TRY MATCH TYPE:"<<type_<<"\n";
        if(type_.find(time_str) != string::npos){
            //return nullptr;
            auto typesub = type_.substr(type_.find(time_str));
            auto spaces = domain_->getTimeSpaces();
            auto sp = spaces[0]; //fairly safely assume it's not empty
            auto spname = trim(typesub.substr(std::string(time_str).length()));
            for(auto sp_ : spaces){
                if(sp_->getName() == spname){
                    sp = sp_;
                    break;
                }
            }
            auto default_value = new string[1];
            default_value[0] = "0";
            return domain_->mkTime("INFERRED", sp,default_value);

        }
        else if(type_.find(duration_str) != string::npos){
            auto typesub = type_.substr(type_.find(duration_str));
            auto spaces = domain_->getTimeSpaces();
            auto sp = spaces[0]; //fairly safely assume it's not empty
            auto spname = trim(typesub.substr(std::string(duration_str).length()));
            for(auto sp_ : spaces){
                if(sp_->getName() == spname){
                    sp = sp_;
                    break;
                }
            }
            auto default_value = new string[1];
            default_value[0] = "0";
            return domain_->mkDuration("INFERRED", sp,default_value);

        }
        else if(type_.find(time_transform_str) != string::npos){
            //return nullptr;
            type_ = type_.substr(type_.find(time_transform_str));
            auto domcodsub = trim(type_.substr(std::string(time_transform_str).length()));
            auto domname = trim(domcodsub.substr(0,domcodsub.find(' ')));
            auto codname = trim(domcodsub.substr(domcodsub.find(' ')));

            auto spaces = domain_->getTimeSpaces();
            //std::cout<<"SIZE OF TIME SPACES??"<<spaces.size()<<"\n";
            auto domsp = spaces[0]; //fairly safely assume it's not empty
            auto codsp = spaces[0];
            for(auto sp_ : spaces){
                //std::cout<<"sp???"<<sp_->getName()<<"\n";
                if(sp_->getName() == domname){
                    domsp = sp_;
                }
                if(sp_->getName() == codname){
                    codsp = sp_;
                }
            }
            //std::cout<<domcodsub<<" "<<domname<<" "<<codname<<"\n";
            //std::cout<<type_<<"\n"<<domsp->toString()<<"\n"<<codsp->toString()<<"\n";
            //auto default_value = new string[1];
            //default_value[0] = "0";
            return domain_->mkTimeTransform("INFERRED", domsp, codsp);
            
        }
        else if(type_.find(position1d_str) != string::npos){
            //return nullptr;
            auto typesub = type_.substr(type_.find(position1d_str));
            auto spaces = domain_->getGeom1DSpaces();
            auto sp = spaces[0]; //fairly safely assume it's not empty
            auto spname = trim(typesub.substr(std::string(position1d_str).length()));
            for(auto sp_ : spaces){
                if(sp_->getName() == spname){
                    sp = sp_;
                    break;
                }
            }
            auto default_value = new string[1];
            default_value[0] = "0";
            return domain_->mkPosition1D("INFERRED", sp,default_value);

        }
        else if(type_.find(displacement1d_str) != string::npos){
            //return nullptr;
            auto typesub = type_.substr(type_.find(displacement1d_str));
            auto spaces = domain_->getGeom1DSpaces();
            auto sp = spaces[0]; //fairly safely assume it's not empty
            auto spname = trim(typesub.substr(std::string(displacement1d_str).length()));
            for(auto sp_ : spaces){
                if(sp_->getName() == spname){
                    sp = sp_;
                    break;
                }
            }
            auto default_value = new string[1];
            default_value[0] = "0";
            return domain_->mkDisplacement1D("INFERRED", sp,default_value);

        }
        else if(type_.find(geom1d_transform_str) != string::npos){
            //return nullptr;
            type_ = type_.substr(type_.find(geom1d_transform_str));
            auto domcodsub = trim(type_.substr(std::string(geom1d_transform_str).length()));
            auto domname = trim(domcodsub.substr(0,domcodsub.find(' ')));
            auto codname = trim(domcodsub.substr(domcodsub.find(' ')));

            auto spaces = domain_->getGeom1DSpaces();
            auto domsp = spaces[0]; //fairly safely assume it's not empty
            auto codsp = spaces[0];
            for(auto sp_ : spaces){
                if(sp_->getName() == domname){
                    domsp = sp_;
                }
                if(sp_->getName() == codname){
                    codsp = sp_;
                }
            }
            //auto default_value = new string[1];
            //default_value[0] = "0";
            return domain_->mkGeom1DTransform("INFERRED", domsp, codsp);
            
        }
        else if(type_.find(timestamped_pose3d_str) != string::npos){
           
            type_ = type_.substr(timestamped_pose3d_str.length());
            type_ = trim(type_);
            auto sppos = charPos(type_, ' ');
            auto tmname = trim(type_.substr(0, sppos[0]));
            //auto domcodsub = trim(type_.substr(std::string(geom3d_transform_str).length()));
            auto spname = trim(type_.substr(sppos[0]));
            auto spaces = domain_->getGeom3DSpaces();
            auto timespaces = domain_->getTimeSpaces();
            auto tmsp = timespaces[0];
            for(auto tm_ : timespaces){
                if(tm_->getName() == tmname){
                    tmsp = tm_;
                }
            }
            auto sp = spaces[0]; 
            for(auto sp_ : spaces){
                if(sp_->getName() == spname){
                    sp = sp_;
                }
            }
            auto default_value_ort = new string[9];
            default_value_ort[0] = "0";
            default_value_ort[1] = "0";
            default_value_ort[2] = "0";
            default_value_ort[3] = "0";
            default_value_ort[4] = "0";
            default_value_ort[5] = "0";
            default_value_ort[6] = "0";
            default_value_ort[7] = "0";
            default_value_ort[8] = "0";
            auto ort = domain_->mkOrientation3D("INFERRED", sp,default_value_ort);
            auto default_value_pos = new string[3];
            default_value_pos[0] = "0";
            default_value_pos[1] = "0";
            default_value_pos[2] = "0";
            auto pos = domain_->mkPosition3D("INFERRED", sp,default_value_pos);
            auto pose_ = domain_->mkPose3D("INFERRED",sp,ort,pos);

            auto tm_value = new string[1];
            tm_value[0] = "0";
            auto time_ = domain_->mkTime("INFERRED",tmsp, tm_value);
            return domain_->mkTimeStampedPose3D("INFERRED", time_, pose_);
        }
        else if(type_.find(timestamped_geom3d_transform_str) != string::npos){
            type_ = type_.substr(timestamped_geom3d_transform_str.length());
            type_ = trim(type_);
            auto sppos = charPos(type_, ' ');
            auto tmname = trim(type_.substr(0, sppos[0]));
            //auto domcodsub = trim(type_.substr(std::string(geom3d_transform_str).length()));
            auto domname = trim(type_.substr(sppos[0],sppos[1]));
            //trim(domcodsub.substr(0,domcodsub.find(' ')));
            auto codname = trim(type_.substr(sppos[1]));//trim(domcodsub.substr(domcodsub.find(' ')));
            auto spaces = domain_->getGeom3DSpaces();
            auto timespaces = domain_->getTimeSpaces();
            auto tmsp = timespaces[0];
            for(auto tm_ : timespaces){
                if(tm_->getName() == tmname){
                    tmsp = tm_;
                }
            }
            auto domsp = spaces[0]; //fairly safely assume it's not empty
            auto codsp = spaces[0];
            for(auto sp_ : spaces){
                if(sp_->getName() == domname){
                    domsp = sp_;
                }
                if(sp_->getName() == codname){
                    codsp = sp_;
                }
            }
            //auto default_value = new string[1];
            //default_value[0] = "0";
            auto tr = domain_->mkGeom3DTransform("INFERRED", domsp, codsp);
            auto tm_value = new string[1];
            tm_value[0] = "0";
            auto time_ = domain_->mkTime("INFERRED",tmsp, tm_value);
            return domain_->mkTimeStampedGeom3DTransform("INFERRED", time_, tr);
        }
        else if(type_.find(position3d_str) != string::npos){
            //return nullptr;
            auto typesub = type_.substr(type_.find(position3d_str));
            auto spaces = domain_->getGeom3DSpaces();
            auto sp = spaces[0]; //fairly safely assume it's not empty
            auto spname = trim(typesub.substr(std::string(position3d_str).length()));
            for(auto sp_ : spaces){
                if(sp_->getName() == spname){
                    sp = sp_;
                }
            }
            auto default_value = new string[3];
            default_value[0] = "0";
            default_value[1] = "0";
            default_value[2] = "0";
            return domain_->mkPosition3D("INFERRED", sp,default_value);

        }
        else if(type_.find(displacement3d_str) != string::npos){
            //return nullptr;
            auto typesub = type_.substr(type_.find(displacement3d_str));
            auto spaces = domain_->getGeom3DSpaces();
            auto sp = spaces[0]; //fairly safely assume it's not empty
            auto spname = trim(typesub.substr(std::string(displacement3d_str).length()));
            for(auto sp_ : spaces){
                if(sp_->getName() == spname){
                    sp = sp_;
                }
            }
            auto default_value = new string[3];
            default_value[0] = "0";
            default_value[1] = "0";
            default_value[2] = "0";
            return domain_->mkDisplacement3D("INFERRED", sp,default_value);

        }
        else if(type_.find(orientation3d_str) != string::npos){
            auto typesub = type_.substr(type_.find(orientation3d_str));
            auto spaces = domain_->getGeom3DSpaces();
            auto sp = spaces[0]; //fairly safely assume it's not empty
            auto spname = trim(typesub.substr(std::string(orientation3d_str).length()));
            for(auto sp_ : spaces){
                if(sp_->getName() == spname){
                    sp = sp_;
                }
            }
            auto default_value = new string[9];
            default_value[0] = "0";
            default_value[1] = "0";
            default_value[2] = "0";
            default_value[3] = "0";
            default_value[4] = "0";
            default_value[5] = "0";
            default_value[6] = "0";
            default_value[7] = "0";
            default_value[8] = "0";
            return domain_->mkOrientation3D("INFERRED", sp,default_value);
        }
        else if(type_.find(rotation3d_str) != string::npos){
            auto typesub = type_.substr(type_.find(rotation3d_str));
            auto spaces = domain_->getGeom3DSpaces();
            auto sp = spaces[0]; //fairly safely assume it's not empty
            auto spname = trim(typesub.substr(std::string(rotation3d_str).length()));
            for(auto sp_ : spaces){
                if(sp_->getName() == spname){
                    sp = sp_;
                }
            }
            auto default_value = new string[9];
            default_value[0] = "0";
            default_value[1] = "0";
            default_value[2] = "0";
            default_value[3] = "0";
            default_value[4] = "0";
            default_value[5] = "0";
            default_value[6] = "0";
            default_value[7] = "0";
            default_value[8] = "0";
            return domain_->mkRotation3D("INFERRED", sp,default_value);
        }
        else if(type_.find(pose3d_str) != string::npos){
            auto typesub = type_.substr(type_.find(pose3d_str));
            auto spaces = domain_->getGeom3DSpaces();
            auto sp = spaces[0]; //fairly safely assume it's not empty
            auto spname = trim(typesub.substr(std::string(pose3d_str).length()));
            for(auto sp_ : spaces){
                if(sp_->getName() == spname){
                    sp = sp_;
                }
            }
            auto default_value_ort = new string[9];
            default_value_ort[0] = "0";
            default_value_ort[1] = "0";
            default_value_ort[2] = "0";
            default_value_ort[3] = "0";
            default_value_ort[4] = "0";
            default_value_ort[5] = "0";
            default_value_ort[6] = "0";
            default_value_ort[7] = "0";
            default_value_ort[8] = "0";
            auto ort = domain_->mkOrientation3D("INFERRED", sp,default_value_ort);
            auto default_value_pos = new string[3];
            default_value_pos[0] = "0";
            default_value_pos[1] = "0";
            default_value_pos[2] = "0";
            auto pos = domain_->mkPosition3D("INFERRED", sp,default_value_pos);
            return domain_->mkPose3D("INFERRED",sp,ort,pos);
        }
        else if(type_.find(geom3d_transform_str) != string::npos){
            //return nullptr;
            type_ = type_.substr(type_.find(geom3d_transform_str));
            auto domcodsub = trim(type_.substr(std::string(geom3d_transform_str).length()));
            auto domname = trim(domcodsub.substr(0,domcodsub.find(' ')));
            auto codname = trim(domcodsub.substr(domcodsub.find(' ')));

            auto spaces = domain_->getGeom3DSpaces();
            auto domsp = spaces[0]; //fairly safely assume it's not empty
            auto codsp = spaces[0];
            for(auto sp_ : spaces){
                if(sp_->getName() == domname){
                    domsp = sp_;
                }
                if(sp_->getName() == codname){
                    codsp = sp_;
                }
            }
            //auto default_value = new string[1];
            //default_value[0] = "0";
            return domain_->mkGeom3DTransform("INFERRED", domsp, codsp);
            
        }
        else if(type_.find(scalar_str) != string::npos){
            //return nullptr;
            auto typesub = type_.substr(type_.find(scalar_str));
            auto spaces = domain_->getTimeSpaces();
            auto default_value = new string[1];
            default_value[0] = "0";
            return domain_->mkScalar("INFERRED", default_value);

        }
        if(error_ == "None")
            return nullptr;
        else
            return new domain::ErrorObject(error_);
    }
    catch(std::exception ex){
        std::cout<<ex.what()<<"\n";
        return nullptr;
    }
};

std::string bootFile = "/peirce/lean_client/boot.touch";
std::string outputFile = "/peirce/lean_client/output.txt";

std::string bootCmd("touch /peirce/lean_client/boot.touch");
std::string readCmd("cat /peirce/lean_client/output.txt");
std::string cleanCmd("rm -rf /peirce/lean_client/output.txt");

void Oracle_LeanInference::buildInterpretations(std::string peirceOutputName){
    this->ordered_interpretations.clear();
    this->all_interpretations.clear();
    std::cout<<"Booting Lean...\n";
    //std::string result = exec_toString(std::string("lean /peirce/") + peirceOutputName + "_CHECK.lean");//method
    //exec_toString(bootCmd);
    std::string bootData("");
    for(auto interp_ : this->all_nodes){
        //std::cout<<"at : "<<interp_->toString()<<"\n";
        if(!interp_->getStartLocation())
        {
            continue;
        }
        bootData = bootData + interp_->getStartLocation()->toShortString()+":"+interp_->getEndLocation()->toShortString()+";";
    }
    exec_toString(std::string("echo \"")+bootData+"\" > /peirce/lean_client/boot_data.txt");

    while(access( outputFile.c_str(), F_OK ) == -1)
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
    }

    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    std::string result = exec_toString(readCmd);
    std::cout<<""<<exec_toString(cleanCmd)<<"";
    
    std::stringstream tosplit(result);

    std::string cur_line;

    bool reading = false;
    int state = 0;
    const int 
        bl = 1,
        bc = 2,
        el = 3,
        ec = 4,
        er = 5,
        ty = 6;
    state = bl;
    std::vector<int> beginLines;
    std::vector<int> beginColumns;
    std::vector<int> endLines;
    std::vector<int> endColumns;
    std::vector<std::string> types;
    std::vector<std::string> errors;
    while(std::getline(tosplit,cur_line))
    {
        int beginLine, beginColumn, endLine, endColumn;
        std::string error = "";
        std::string type = "";
        std::string parsing = "";
        interp::Interp* matched = nullptr;
        state = 1;
        for (std::string::size_type i = 0; i < cur_line.size(); i++) {
            auto c = cur_line[i];
            //std::cout<<"ST:"<<c<<" "<<parsing<<" "<<reading<<" "<<state<<"END\n"<<std::flush;
            switch(state)
            {
                case 1:{
                    if(reading){
                        if (c == ','){
                            reading = false;
                            beginLine = std::stoi(parsing);
                            parsing = "";
                            state =2;
                        }
                        else
                            parsing += c;
                    }
                    else if(c == '='){
                        reading = true;
                    }
                } break;
                case 2:{
                    if(reading){
                        if (c == ','){
                            reading = false;
                            beginColumn = std::stoi(parsing);
                            parsing = "";
                            state =3;
                        }
                        else
                            parsing += c;
                    }
                    else if(c == '='){
                        reading = true;
                    }
                } break;
                case 3:{
                    if(reading){
                        if (c == ','){
                            reading = false;
                            endLine = std::stoi(parsing);
                            parsing = "";
                            state =4;
                        }
                        else
                            parsing += c;
                    }
                    else if(c == '='){
                        reading = true;
                    }
                } break;
                case 4:{
                    if(reading){
                        if (c == ','){
                            reading = false;
                            endColumn = std::stoi(parsing);
                            parsing = "";
                            state =5;
                        }
                        else
                            parsing += c;
                    }
                    else if(c == '='){
                        reading = true;
                    }
                } break;
                case 5:{
                    if(reading){
                        if (c == ','){
                            reading = false;
                            error = parsing;
                            parsing = "";
                            state =6;
                        }
                        else
                            parsing += c;
                    }
                    else if(c == '='){
                        reading = true;
                    }
                } break;
                case 6:{
                    if(reading){
                        if (c == ')'){
                            reading = false;
                            type = parsing;
                            parsing = "";
                        }
                        else
                            parsing += c;
                    }
                    else if(c == '='){
                        reading = true;
                    }
                } break;
                default: throw "Shouldn't be here!";
            }
        }

        beginLines.push_back(beginLine);
        beginColumns.push_back(beginColumn);
        endLines.push_back(endLine);
        endColumns.push_back(endColumn);
        types.push_back(type);
        errors.push_back(error);
        //std::cout<<"Extracted match ("<<beginLine<<","<<beginColumn<<","<<endLine<<","<<endColumn<<","<<type<<","<<error<<")\n";
    }

    for(auto interp_:this->all_nodes)
    {
        auto start = interp_->getStartLocation();
        auto end = interp_->getEndLocation();
        if (start != nullptr and end != nullptr)
        {
            //std::cout<<interp_->toString()<<"\n";
            //std::cout<<interp_->getCoords()->getNodeType()<<" "<<start->toString()<<" "<<end->toString()<<"\n";
            bool found = false;
            for(auto i = 0;i<beginLines.size();i++)
            {
                if(
                    start->getLine() == beginLines[i] and
                    start->getColumn() == beginColumns[i] and 
                    end->getLine() == endLines[i] and 
                    end->getColumn() == endColumns[i]){
                    //std::cout<<"Found match "<<beginLines[i]<<" "<<beginColumns[i]<<" "<<endLines[i]<<" "<<endColumns[i]<<" "<<types[i]<<" "<<errors[i]<<"\n";
                    //std::cout<<this->all_nodes[i]->getCoords()->getNodeType()<<"\n";
                    //std::cout<<types[i]<<" "<<errors[i]<<"\n";
                    
                    this->all_interpretations.push_back(parseInterpretation(types[i], errors[i]));
                    found = true;
                    break;
                }
            }
            if(!found){
                //std::cout<<"WARNING NOT FOUND!\n";
                this->all_interpretations.push_back(nullptr);
            }
        }
        else 
            this->all_interpretations.push_back(nullptr);
    }

    for(auto interp_:this->ordered_nodes)
    {
        auto start = interp_->getStartLocation();
        auto end = interp_->getEndLocation();
        if (start != nullptr and end != nullptr)
        {
            for(auto i = 0;i<beginLines.size();i++)
            {
                if(
                    start->getLine() == beginLines[i] and
                    start->getColumn() == beginColumns[i] and 
                    end->getLine() == endLines[i] and 
                    end->getColumn() == endColumns[i]){
                    //std::cout<<"Found match "<<beginLines[i]<<" "<<beginColumns[i]<<" "<<endLines[i]<<" "<<endColumns[i];
                    this->ordered_interpretations.push_back(parseInterpretation(types[i], errors[i]));
                }
            }
        }
    }

    for(auto i = 0 ;i<this->all_nodes.size();i++){
        //std::cout<<"RES"<<i<<this->all_nodes[i]->getCoords()->getNodeType()<<"\n";
        //std::cout<<this->all_nodes[i]->toString()<<"\n";
       // if(this->all_interpretations[i]){
        //    std::cout<<this->all_interpretations[i]->toString()<<"\n";
       // }
        //else
        //    std::cout<<"Missing Interp...\n";
    }
    //the type of the left hand side of a declaration is the type of the overall expression on the right hand side
    for(auto interp_:this->all_nodes)
    {
        if(interp_->getCoords()->getNodeType().find("DECL") != string::npos)
        {
            auto lhs_ = interp_->getOperand(0);
            auto rhs_ = interp_->getOperand(1);
            //std::cout<<lhs_->getCoords()->getNodeType()<<" "<<lhs_->toString()<<"\n"<<rhs_->getCoords()->getNodeType()<<" "<<rhs_->toString()<<"\n";
            int lhsloc;
            //std::cout<<"CHECK FOR "<<interp_->toString();
            for(auto i = 0 ; i < this->all_nodes.size();i++)
            {
                auto interp__ = this->all_nodes[i];
                if(lhs_ == interp__)
                    lhsloc = i;
            }
            //std::cout<<"LHS LOC!!"<<lhsloc<<"\n";
            //std::cout<<this->all_nodes[lhsloc]->getCoords()->getNodeType()<<" "<<this->all_nodes[lhsloc]->toString()<<"\n";

            for(auto i = 0 ; i < this->all_nodes.size();i++)
            {
                auto interp__ = this->all_nodes[i];
                if(rhs_ == interp__){
                    //std::cout<<"START\n";
                    //std::cout<<rhs_->toString()<<std::flush;
                   // std::cout<<interp__->toString()<<std::flush;
                    auto dom_ = getAllInterpretation(interp__->getCoords());
                    auto old_ = getAllInterpretation(lhs_->getCoords());
                    //std::cout<<dom_<<"\n"<<old_<<"\n"<<this->all_interpretations[lhsloc]<<"\n"<<lhsloc<<"\n";
                    //if(dom_){
                    //    std::cout<<dom_->toString()<<"\n"<<std::flush;
                    //}
                    //if(old_){
                    //    std::cout<<old_->toString()<<"\n"<<std::flush;
                    //}
                   ////   std::cout<<"Missing dom\n";
                    //}
                    if(old_ ==nullptr){
                        //std::cout<<"Assigning\n";
                        this->all_interpretations[lhsloc] = dom_;
                    }
                    else{
                        //std::cout<<"NOT Assigning\n";
                    }
                }
            }
            lhsloc = -1;
            for(auto i = 0 ; i < this->ordered_nodes.size();i++)
            {
                auto interp__ = this->ordered_nodes[i];
                if(lhs_ == interp__)
                    lhsloc = i;
            }
            if (lhsloc > -1){
                for(auto i = 0 ; i < this->ordered_nodes.size();i++)
                {
                    auto interp__ = this->ordered_nodes[i];
                    if(rhs_ == interp__){
                        //std::cout<<"START2\n";
                        //std::cout<<rhs_->toString()<<std::flush;
                        //std::cout<<interp__->toString()<<std::flush;
                        auto dom_ = getInterpretation(interp__->getCoords());
                        auto old_ = getInterpretation(lhs_->getCoords());
                        //std::cout<<dom_<<"\n"<<old_<<"\n"<<this->ordered_interpretations[lhsloc]<<"\n"<<lhsloc<<"\n";
                        if(dom_){
                          //  std::cout<<dom_->toString()<<"\n"<<std::flush;
                        }
                        if(old_){
                           // std::cout<<old_->toString()<<"\n"<<std::flush;
                        }
                        else{
                           // std::cout<<"Missing dom\n";
                        }
                        if(old_ ==nullptr){
                          //  std::cout<<"Assigning\n";
                            this->ordered_interpretations[lhsloc] = dom_;
                        }
                        else{
                           // std::cout<<"NOT Assigning\n";
                        }
                    }
                }
            }
        }
    }

    for(auto i = 0 ;i<this->all_nodes.size();i++){
        //std::cout<<"RES"<<i<<this->all_nodes[i]->getCoords()->getNodeType()<<"\n";
        //std::cout<<this->all_nodes[i]->toString()<<"\n";
        if(this->all_interpretations[i]){
            //std::cout<<this->all_interpretations[i]->toString()<<"\n";
        }
       // else
            //std::cout<<"Missing Interp...\n";
    }
};
